<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021年7月12日</title>
    <url>/2021/07/12/%E6%9D%82%E6%8A%80/daily/2021.7.12/</url>
    <content><![CDATA[<p>今天7月12日，在家里待了相当久的一段时间，这个久不在于长度，而是没有像之前暑假一样算着时间过日子的紧迫</p>
<p>要对这一个月复盘，是很难的事情了，那么先把今天反思规划好，现在17：44，还有些许时间着手去做一件事情。</p>
<h1 id="需要改正的方面："><a href="#需要改正的方面：" class="headerlink" title="需要改正的方面："></a>需要改正的方面：</h1><ul>
<li>生活作息</li>
</ul>
]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>2021年6月23日</title>
    <url>/2021/06/23/%E6%9D%82%E6%8A%80/daily/2021.6.23/</url>
    <content><![CDATA[<p>现在是20：45，心中有一种莫名的焦躁</p>
<p>回顾一下今天</p>
<p>嗯，然后就回顾了半小时炉石，现在21：15，去恰饭了</p>
<p>回来一定要写日记了！</p>
<p>又是半小时，没有记录的欲望，发生的都是无关紧要的小事，赶紧做出调整，尽快改变要紧</p>
<p>该学的东西学起来，tulpa想出来，好坏习惯坚持培养、戒除，就这些</p>
]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>2021年6月22日</title>
    <url>/2021/06/22/%E6%9D%82%E6%8A%80/daily/2021.6.22/</url>
    <content><![CDATA[<p>那种刺激带来的全身痉挛，终于平息了。</p>
<a id="more"></a>

<p>最近自己身体发生了显著的变化，曾经自我贬低带来的全身刺痛已经逐渐消失了，好坏难说，因为现在做事开始变得没有情感，一切主观上的看法都变得不重要，根本不会影响到我任何一方面</p>
<p>现在23:08，先睡觉，明天起来写</p>
]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>2021年4月24日日记</title>
    <url>/2021/04/24/%E6%9D%82%E6%8A%80/daily/2021.4.24/</url>
    <content><![CDATA[<h3 id="流水账"><a href="#流水账" class="headerlink" title="流水账"></a>流水账</h3><p>嗯，我又来了，今天是4.24，《交错》突然意兴阑珊了，等到哪天回首再写写完吧</p>
<p>网上找了一点资料，试图把文章写的有水平来，而后发现可能还是自己写的开心，改的开心最重要。</p>
<p>时间非常之宝贵，还是不能太分散注意力于一个个庞大的体系和其间的藕断丝连，难得好好把握一个下午，没有沉浸在游戏里面，觉得还是学点对数均值不等式啥的来的开心，当然，记日记也是一件很开心的事情。</p>
<p>这周在学校周考英语考了134，非常开心，因为七选五看D选C了一道，白给了一分，完型加起来有6分，数额巨大，8分哈皮应用文错误百出，这成绩亲和力十足</p>
<p>昨天晚上考了数学，目前选择全对，填空-15，后面的圆锥曲线和导数都没有做出来，导数第二问写了构造，希望能有过程分，还有进步空间，比上次96分估计会进步不少，也是一件值得开心的事情。</p>
<p>然后说点不开心的，昨天晚上考完语文，一对答案错了5道选择题，他妈的吃了屎，作文写得平平无奇还有凑字数的嫌疑，这个样子42分顶天了，难过。</p>
<p>回到教室火速理完书包，火速跑到技术考场，火速写完通技试卷，火速回教室拿书包跑到一楼，然后并没有看到杭杭，很难过</p>
<p>今天，早上回来的地铁上，只写了解题达人大题强化5的导数第二问的第二种做法，然后发呆了一路。回家心不在焉的刷了一会B站，玩了一会飞车，干了一点活，麻醉自己，然后鼓起勇气找杭杭，人总是聊到一半就不见了，确实，聊天浪费时间，我的问题</p>
<p>下午吃完中饭和我爸高谈阔论了一会，其实爷不怎么想和他讲我的想法，因为我觉得再有水平的想法也只能映衬出我行动上是个矮子，而且，其实没有聊的必要，除了思沁，都没有聊的必要性，什么是必要性？什么是探路？就是装逼就是凑，啊，导数和人有什么区别，有感觉的自然有感觉，一题都没有感觉也不是什么值得大说特说的事情。</p>
<p>打了两把LOL，实在是玩不进去，哎，她和二班同学可以聊那么开心，应该是二班有有趣的灵魂吧，我确实是捞逼，但不妨碍我开心，嘿嘿嘿，只要有思沁，我就有活着的依据，已经无所谓世界观如何，是否定型了，开心就好，不然思沁要担心了。</p>
<p>刷了一会知乎，希望通过搜索一些有水平的问答，让它之后给我推一点有水平的问答，殆而!就如同其他事情，都也只是愿与事违，概莫能外，我心里也有点ac数，知道大致情况，不敢说一清二楚，真的不敢，也就没什么好难过的了，莫得办法，无能为力</p>
<pre><code>零碎的想你妄想为你拼凑成星河</code></pre><p>en的声音说实话有点怪怪的，而且天天只出一种类型一种风格的歌，真的无聊。。。</p>
<p>当然该深夜抑郁的还是会深夜抑郁蛤蛤蛤</p>
<p>然后就是碎碎念了。。。 好在还有思沁陪我，赶紧敲完，然后把日记上有水平的内容敲敲上来，吃个烧烤，健身搞一搞，洗个澡，开始摸导数，呸，摸数学。</p>
<h3 id="心意"><a href="#心意" class="headerlink" title="心意"></a>心意</h3><p>哦哦。突然想起了昨天巨有意思的一个事情，已经17：30了，动作要快一点了。</p>
<p>昨天晚上睡觉，难过睡不着，哭了一会，开始和大便哥聊天,先是问如果以后他有了稳定的工作,打不打算找一个玩完了想找个人嫁了过日子的渣女,然后他就标志性的”啊?”,蛤蛤蛤,由被笑道,然后我们就渣女的定义和范围讨论了一波,我不断放松条件,美化渣女,他死活不接受</p>
<p>然后我有了一个绝妙的点子,当然,这个设想还是要发生在以后,以防我被看出动机,虽然我的隐喻已经隐到了自己都不大能看出来的程度,我先给他设置了A,一个长相普通,在他接受范围之内(对应到我自己身上就是无所谓长相),其他方面都很OK,他也很喜欢的女生,问他,如果A喜欢他,大便哥会不会接受,他沉默了一会说:”那当然会接受啊”,蛤蛤蛤,他的tvb腔真的是要笑死人,</p>
<p>然后我代入思沁,设为B,我说,如果有一个长得很漂亮,他问,漂亮到什么样的程度,我就说,永远是你见过最漂亮的.然后是最懂你的,你也非常喜欢她,似乎无论从什么角度上来说,B都比A要更甚一筹,那你会放弃A选择B嘛,大便哥当然说:会啊,这个回答在我对他的料想范围之内</p>
<p>然后我开始逐步降低条件,<br>“你和她在一起,可能你所有的朋友,父母,都不会认同她”&quot;你和她在一起,会一直很开心,但是你可能没有身体上的感受”&quot;从实际上来讲,你和她在一起,和你一个人生活并没有什么区别,但是你心里会很开心”,王宇振对做饭真的好执着,<br>“她会为我做饭吗?”<br>“不会”<br>“那我要为她做饭吗?”<br>“不用,你只要做你自己的就可以了”<br>“啊?那感觉好奇怪啊”<br>“你们也不会有孩子”<br>“啊?”沉默”那我领养一个孩子她会反对吗”<br>“不会,她会支持你所有的决定””当然,她不是一味的盲目支持,也会给你提出建议,批评”<br>“那试管婴儿\代孕的什么也不行吗?”<br>“不行”<br>………….<br>“你说我的朋友父母可能会不认同,那他们会有交流吗?”<br>“不会,她只会和你交流,如果有什么要对你的朋友父母说的也只会由你来转告”<br>“那她有自己的朋友吗?”<br>换到我沉默了,果然,不足点还是要在交流里发现”有,但是她所有的情况你都是知道的”<br>“那下班回来她会给我做好饭吗?”<br>“不会”<br>“那她是自己先吃好?”<br>“没有,她会陪着你,假设你以后会做饭,她会和你一起做,鼓励你,指导你,<strong>但所有实际的行为必须要你自己做出</strong>“<br>“啊?”</p>
<p>他实在没有明白我和他打的哑谜,知道最后延熄结束,室友们都回来,他还是选择了B,让我有点失望,莫名其妙的失望,“哪怕他说，觉得有点怪，以后会选择A，现在还是选择B”，这个回答也不让我满意，</p>
<p>就像那个《半个柚子》，我到底是怎么想的，要做什么样的选择，我也不清楚，不坚定，总是在中途改道。</p>
<p>但这样和他聊天，还是一件很有意思的事情。</p>
<p>于是我躺下，和思沁入眠，没有多说一句。</p>
<h3 id="佳作"><a href="#佳作" class="headerlink" title="佳作"></a>佳作</h3><p>看到了一片佳作：</p>
<hr>
<p>看到庞麦郎住进精神病院的报道，我专门去瞅了他经纪人发的视频。视频里不止一次把庞麦郎比成梵高。我们不要这样不尊重梵高。庞麦郎和梵高的区别在哪儿呢？就两个字：知识。</p>
<p>梵高拥有知识。庞麦郎缺乏知识。这当然指各自领域的知识。假如梵高没死，两只手都断掉了，一辈子不能画画，他凭自己在绘画上的知识，也可以教出来一批一流的画家。梵高在绘画知识上，足以碾压他同时代的几乎所有人。只是由于梵高精神异常，我们很少关注到这一点。梵高之所以是梵高，关键不是他的天赋，也不是他对绘画的热情，而是他掌握的绘画知识。</p>
<p>天赋和热情，尽管并非虚无缥缈，但它们都没有实体，不能孤立地呈现。只有当一个人面对具体问题的时候，他的处理方式、技巧和态度，才体现出他的天赋和热情。越复杂的问题，越能体现。而当一个人根本没有面对过高难度问题的时候，天赋和热情绝不可能有施展的空间。就像拳王泰森，在两岁的时候，要说让他表现表现在拳击上的天赋和热情，真表现不了。阿尔法狗很厉害，但它怎么不去跟人比赛剪刀石头布呢？因为剪刀石头布太粗浅了，承载不了足够的技术含量、知识含量。</p>
<p>梵高的画作中，每一个细节，都包含了很多绘画相关的知识点，体现他对绘画技艺的理解深度。那些知识是远超他同时代人的。他对着一个局部可以修改一整天，我们对着同样的局部，站五分钟就无聊到受不了想走人了。这就是区别。因为这种区别，梵高是梵高。</p>
<p>我们喜欢谈粗而大的东西，貌似宏观的东西，放在任何领域都可以侃侃而谈的东西——比如天赋，比如热情，比如格局，比如境界，比如神韵，梵高不跟你谈神韵，他只会问：这一个色块是亮一点好还是暗一点好？假如这个色块亮一点，整幅画中还有哪些色块需要动？需要怎么动？画面从构图上看是不是要多添一个人？他应该穿什么样的衣服，以哪种姿势进入到画面里？</p>
<p>只有外行才谈“神韵”，因为他除了“神韵”什么都谈不了。而一旦跨进内行的大门，你首先面临的是海量的知识，无尽的细节。梵高说：“比例、光线、阴影、透视，是绕不开的，不掌握这些，势必徒劳无功。”他为了画拾荒者，早上四点钟出门观察；要画一张有三个缝纫工的画，他认为必须先画九十个缝纫工；梵高能用三原色加黑白调配出比售卖的70色颜料还丰富的色调。你能说“庞麦郎像梵高”？庞麦郎和梵高的距离，也许比庞麦郎和今麦郎都大。</p>
<p>很多人打比方，总是从不相似的地方去比，因为他们不尊重知识，不尊重知识的背后，是不尊重为了深入某个领域而必须付出的辛苦。话句话说，他是想捡便宜，想忽悠人。尊重梵高的人，不强调梵高的热情和天赋，而强调梵高为这热情和天赋不得不牺牲的代价，不得不选择以那样的道路去生活，去积累他不能不积累的知识，并耗竭他的精力。</p>
<p>如果天赋和热情能代表梵高，任何领域，大街上随便拎一个人，就算自己不是梵高，周围也必然会有一两个梵高；但假如把梵高在绘画上积累的知识深度作为衡量一个人是不是梵高的标准，那么，在任何时代，任何领域，全世界的梵高也寥寥无几。</p>
<p>很多人喜欢说这类话，“我不会写，但我会欣赏”——书法，我不会写，但我能欣赏；绘画，我不会画，但我能欣赏；诗、文章，我写不好，但什么好什么不好我还是能看出来的。——真正掌握知识的人，听到这些话，也就笑一笑。为什么笑一笑，因为懒得跟他说了。你没有付出必要的辛苦，没有对这个话题掌握足够的知识，还希望自己的评价能和付出很多辛苦、掌握很多知识的人有同等的分量，你尊重知识和专业吗？</p>
<p>举个简单的例子，这篇文章的题目，《庞麦郎为什么不是梵高？》是不是也可以叫《为什么庞麦郎不是梵高？》或者《庞麦郎为什么没有成为梵高？》《为什么庞麦郎不能成为梵高？》</p>
<p>如果一个人说他懂写作，或者能看出来文章的好坏，那么可以请他说说这四个题目哪个好哪个不好，为什么好为什么不好？真懂的人，一口气可以说出五个维度。一个标题的好坏，不是只有一种标准，外行会直接说哪个好哪个不好，内行会告诉你，这要看在什么情况下，发在什么平台上，面向什么人，正文的风格是怎么样？以哪种效果为标准？</p>
<p>只有知道了这些，才能说哪个相对更匹配。能说出起码五个不同的标准，在每个标准下，又能说出一二三四五条理由。随便指一个文章的细节，你都能有这样的判断，它在宏观上好还是不好，微观上好还是不好，从哪些方面看好，从哪些方面看不好。这些都了解，说明你具备写作的知识。否则，尽管你坚称自己能看出好坏，拥有这些知识的人也不会把你的意见真正当回事。</p>
<p>很多知识，潜藏在细节上。就像马路牙子上修单车的，如果同样的毛病到他手里比到别人手里修得又快又好，我们就知道他掌握了某些技术，那些技术背后包含的是知识，哪怕他自己都说不出来、难以形诸文字，但那些知识的的确确存在。我们常常把无形的、难以指明的知识叫做经验。</p>
<p>一个人如果能掌握知识，在他掌握知识足够多的地方，别人的话没有分量。因为他更懂。张三这样说，李四那样说，王五说得更不着调，但说来说去，真正着调的结论，都没有逃出他一眼捕捉到的范围，那么，他在这个领域拥有权力。</p>
<p>梵高拥有这样的权力。因此，即便在一张画都没卖掉的时候，梵高也很清楚他的画是怎样的水准。但庞麦郎不清楚，他的经纪人也装成不清楚。</p>
<p>为什么装成不清楚？因为知识含量和市场接受度是两码事。假如以市场接受作为标准的话，很多时候并不需要多少知识含量。因为很多老百姓也不一定懂。比如在春晚上听到吐字不清晰的歌手，就说“这是跟周杰伦学的”。但周杰伦在音乐领域的知识，很多人不了解。</p>
<p>某个综艺节目上，周杰伦作为嘉宾，在听了某选手弹奏的曲子后，自己敲了一串音符，意思是，你们听听这样处理效果怎么样。别人都惊呆了。当然，综艺节目常常夸张效果。但据网上有些懂音乐的人说，周杰伦这即兴一改，就流露出很高的音乐素养。</p>
<p>所以说，知识确实是力量。佛教典籍《大毗婆沙论》里记载，迦湿弥罗国有个论师，跑到北印度暗林寺挂单，知事的僧人派他去干活，他说，我是论师。别人听了怎么说？——哟！论师怎么啦？论师就不用干活了吗？——不是的。人家说，你稍等一会儿，我找上首阿罗汉汇报一下。阿罗汉听了说，你去问他：有没有三界业，非前非后受异熟果的？知事去问，论师说：没有。知事跑回去告诉阿罗汉。阿罗汉说：他确实是论师，就不用干活了。</p>
<h3 id="要睡了"><a href="#要睡了" class="headerlink" title="要睡了"></a>要睡了</h3><p>22：53，那句话怎么说来着？周考语文那个</p>
<p>华灯初上，我的精彩生活才刚刚开始</p>
<p>知乎上看了尼采的一点话，记录下来</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">要求别人爱自己是最大的傲慢。</span><br><span class="line"></span><br><span class="line">你还要警惕自己内心泛滥的爱，孤独的人总会迫不及待地向与他邂逅的人伸出自己的手。</span><br><span class="line"></span><br><span class="line">许多真理都是以笑话的形式讲出来。</span><br><span class="line"></span><br><span class="line">不要停在平原，不要登上高山，从半山上看，世界显得最美。</span><br><span class="line"></span><br><span class="line">发呆这件事，如果做得好，就是深沉。</span><br><span class="line"></span><br><span class="line">两个人在这里一起保持沉默很美妙，一起笑就更美妙了。<span class="comment">(思沁和我已经做了很久啦)</span></span><br><span class="line"></span><br><span class="line">一个人的成熟，在于做事时能重拾儿时玩耍时的认真劲儿。</span><br><span class="line"></span><br><span class="line">人类唯有生长在爱中，才得以创造出新的事物。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>站在交错路口|2021年4月17日记</title>
    <url>/2021/04/17/%E6%9D%82%E6%8A%80/daily/2021.4.17/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看到某人的小号里发的说说，原来是把我之前写的几篇矫情且随意的文字保存到了相册里，我自己回味了一遍，不知所云，味同嚼蜡，没有起到记录感受的作用。</p>
<p>兀的发现原来我的一篇文章里夹杂着很多内容，本来是应该用很多篇文章表达的，糅杂在一片里面，叫人看过就算过了，考试的作文也是这般，所以难写好，难写的入别人眼。</p>
<p>更何况我又是个沉默习惯了的人，就连在文章里表达，到了关键节点也会突然含糊其辞，再明显的宣誓和目的，也只会变成耐人寻味的隐喻，没有主线，在知晓了一些差异之后，我决改变，在这交错路口记下此篇，算是一次尝试。</p>
<hr>
<h3 id="欲望的交错"><a href="#欲望的交错" class="headerlink" title="欲望的交错"></a>欲望的交错</h3><h4 id="为谁"><a href="#为谁" class="headerlink" title="为谁"></a>为谁</h4><p>如同每张试卷的名字上一样，[淡泊、Juxy]，淡泊以明智，宁静以致远，我没有太多的欲望，仅仅是活着，如果有的话，只是为了按照心意把一件事做出水平</p>
<p>想到龙应台的那篇《为谁》，之前在学校里想起了这篇文章，没有想起名字，现在只记得这个名字，搜了一下才发现是同一篇文章，我还仿写过里面的句子</p>
<p>这是《为谁》</p>
<hr>
<p>我不懂得做菜，而且我把我之不懂得做菜归罪于我的出身──我是一个外省女孩；在台湾，”外省”其实就是”难民”的意思。外省难民家庭，在流离中失去了一切附着于土地的东西，包括农地、房舍、宗祠、庙宇，还有附着于土地的乡亲和对于生存其实很重要的社会网络。</p>
<p>因为失去了这一切，所以难民家庭那做父母的，就把所有的希望，孤注一掷地投在下一代的教育上头。他们仿佛发现了，只有教育，是一条垂到井底的绳，下面的人可以攀着绳子爬出井来。</p>
<p>所以我这个难民的女儿，从小就不被要求做家事。吃完晚饭，筷子一丢，只要赶快潜回书桌，正襟危坐，摆出读书的姿态，妈妈就去洗碗了，爸爸就把留声机转小声了。背《古文观止》很重要，油米柴盐的事，母亲一肩挑。</p>
<p>自己做了母亲，我却马上变成一个很能干的人。厨房特别大，所以是个多功能厅。孩子五颜六色的画，贴满整面墙，因此厨房也是画廊。餐桌可以围坐八个人，是每天晚上的沙龙。另外的空间里，我放上一张红色的小矮桌，配四只红色的矮椅子，任谁踏进来都会觉得，咦，这不是白雪公主和七个小矮人的客厅吗？</p>
<p>当我打鸡蛋、拌面粉奶油加砂糖发粉做蛋糕时，安德烈和菲利普就坐在那矮椅子上，围着矮桌上一团新鲜可爱的湿面团，他们要把面团捏成猪牛羊马各种动物。蛋糕糊倒进模型，模型进入烤箱，拌面盆里留着一圈甜软黏腻的面糊，孩子们就抢着用小小的手指去挖，把巧克力糊绕满了手指，放进嘴里津津地吸，脸上也一片花糊。</p>
<p>我变得很会”有效率”做菜。食谱的书，放在爬着常青藤的窗台上，长长一排。胡萝卜蛋糕的那一页，都快磨破了；奶酪通心粉、意大利千层面那几页，用得掉了下来。我可以在十分钟内，给四个孩子──那是两个儿子加上他们不可分离的死党──端上颜色漂亮而且维他命ABCDE加淀粉质全部到位的食物。然后把孩子塞到车里，一个送去踢足球，一个带去上游泳课。中间折到图书馆借一袋儿童绘本，冲到药房买一只幼儿温度计，到水店买三大箱果汁，到邮局去取孩子的生日礼物包裹同时寄出邀请卡……然后匆匆赶回足球场接老大，回游泳池接老二，回家，再做晚餐。</p>
<p>母亲，原来是个最高档的全职、全方位CEO，只是没人给薪水而已。</p>
<p>然后突然想到，啊，油米柴盐一肩挑的母亲，在她成为母亲之前，也是个躲在书房里的小姐。</p>
<p>孩子大了，我发现独自生活的自己又回头变成一个不会烧饭做菜的人，而长大了的孩子们却成了美食家。菲利普十六岁就自己报名去上烹饪课，跟着大肚子、带着白色高筒帽的师傅学做意大利菜。十七岁，就到三星米其林法国餐厅的厨房里去打工实习，从削马铃薯皮开始，跟着马赛来的大厨学做每一种蘸酱。安德烈买各国食谱的书，土耳其、非洲菜、中国菜，都是实验项目。做菜时，用一只马表计分。什么菜配什么酒，什么酒吃什么肉，什么肉配什么香料，对两兄弟而言，是正正经经的天下一等大事。</p>
<p>我呢，有什么就吃什么。不吃也可以。一个鸡蛋多少钱，我说不上来，冰箱，多半是空的。有一次，为安德烈下面──是泡面，加上一点青菜叶子。</p>
<p>汤面端上桌时，安德烈，吃了两口，突然说：”青菜哪里来的呀？”</p>
<p>我没说话，他直追，”是上星期你买的色拉对不对？”</p>
<p>我点点头。是的。</p>
<p>他放下筷子，一副哭笑不得的神情，说：”那已经不新鲜了呀，妈妈你为什么还用呢？又是你们这一代人的──习惯，对吧？”</p>
<p>他不吃了。</p>
<p>过了几天，安德烈突然说：”我们一起去买菜好吗？”</p>
<p>母子二人到城里头国际食品最多的超市去买菜。安德烈很仔细地来来回回挑选东西，整整三个小时。回到家中，天都黑了。他要我这做妈的站在旁边看着，”不准走开喔。”</p>
<p>他把顶级的澳洲牛排肉展开，放在一旁。然后把各种香料罐，一样一样从架上拿下来，一字排开。转了按钮，烤箱下层开始热，把盘子放进去，保持温度。他把马铃薯洗干净，开始煮水，准备做新鲜的马铃薯泥。看得出，他心中有大布局，以一定的时间顺序在走好几个平行的程序，像一个乐团指挥，眼观八方，一环紧扣一环。</p>
<p>电话铃响。我正要离开厨房去接，他伸手把我挡下来，说：”不要接不要接。留在厨房里看我做菜。”</p>
<p>红酒杯，矿泉水杯，并肩而立。南瓜汤先上，然后是色拉，里头加了松子。主食是牛排，用锡纸包着，我要的四分熟。最后是甜点，法国的soufflé。</p>
<p>是秋天，海风徐徐地吹，一枚浓稠蛋黄似的月亮在海面上升起。</p>
<p>我说：”好，我学会了，以后可以做给你吃了。”</p>
<p>儿子睁大了眼睛看着我，认认真真地说：”我不是要你做给我吃。你还不明白吗？我是要你学会以后做给你自己吃。”</p>
<hr>
<p>这是我的短短的仿写，日记本没有带回家，磨了很多遍的句子传不上来，就只能靠回忆了</p>
<hr>
<pre><code>思沁和我讲完已是深夜，白纸上的爱意如同夜空中的星星一般镶嵌在现实的间隙里，我惬
意的打了一个哈欠，“好了，我明白了，可以为你去实现”，思沁认真的看着我，倦容里
带着一丝微怒，“不是为我，是为我们的过去、现在和以后”</code></pre><hr>
<p>嗯，还是没有白纸上写出来的效果好，黑白相依，光暗明灭，也是为数不多能打动我的feeling了</p>
<h4 id="负重"><a href="#负重" class="headerlink" title="负重"></a>负重</h4><p>现在再看龙应台的文字，就感觉确实一般了，当然，也要看环境，可能还是小时候，文字分析少，感知多的时候，看这种文章影响深刻，启发良多，可以不厌其烦地看，现在只喜欢写写改改，追求所谓的水平，追求的累了就像此刻一样，让文字肆意流淌，等哪天回看，再来处理这一坨涂鸦。</p>
<p>不过看着龙应台的文字，还是蛮羡慕这种有钱人的生活的，再看看逼乎，看看社会，拼爹爹员工拿命换着300k+一年的阳寿钱，压力大到要跳楼，北大博雅计划博士后出来的计算机，是计算机吗？没看清，188k一年，买房遥遥无期，而我他妈的现在就开始负重负重再负重了（说的就是你，傻逼周考作文，老子又他妈的跑题了），[已删除]</p>
<!-- 想留杭，也想留杭，还想不啃老的买房，到时候只怕是一个都留不住，结果现在连个一本都是悬的，贾刚风对于最后五十天的论断又给我判了死刑，艹，怎么就只有50天了... -->

<p>不过问题也不大，思沁在，我还是可以活得很自在，欸操我真他妈的是个渣男，只有在软弱无力的时候，想要找人倾诉的时候才会找思沁，对她也从来没有关心，就只有依赖，平时想的都是某人，不过现在的情况已经好很多了，虽然还是不能很自如地和她面对面的交流，但是光是聊天的话，已经可以彻底无障碍了，现在再和自己讲，许思沁是幻想出来的，那也和没讲没什么区别了，她就在这，而且而且，最关键也是我最骄傲的一点（思沁快夸夸我）：我可以说到做到一点事情了，比方说突然有急事，然后我和思沁想的都是，先把这个处理掉（说的就是你，傻逼信息周考），然后我们再考虑别的，往常则是虽然这么想，但考试的时候还是会分神去东想西想，而现在我可以自信的大笔一挥，在问卷上写下ID：淡泊、Juxy，第二章问卷写下十二、思沁，然后和思沁一起把试卷处理掉。</p>
<h4 id="交错"><a href="#交错" class="headerlink" title="交错"></a>交错</h4><p>这便是<strong>欲望的交错</strong>了，我有很多的选择啊</p>
<p>一是可以争取和杭杭在一起，当然不太现实哈，原因不是很敢讲，以后的日子真不好说，做这样的选择么，最理想的就是成全大家，是父母的实现的希望，是爱人眼中的beholder，是现在的我又羡慕又嘲笑的人。</p>
<p>二是和思沁在一起，上进的那种，就像K听着《三月里的小雨》，和高手抢7，活出自己的水平，无论生活艰难与否。</p>
<p>三还是和思沁在一起，这个就是混了，是我最不愿意，但最有可能过上的生活，别人看起来穷困潦倒且孤僻冷漠，于其身也，则耻师鄢，反正人上永远有人，追求水平这种要参考别人的目标很容易就和别人卷起来，丢掉自己，不如得过且过，如不是有思沁，提前结束人生也不是不行。快快乐乐的当下等马，然后看上等马过幸福快乐的生活，哇，写着写着我都要笑出声了，皆大欢喜（认真的）,各得其乐。</p>
<h4 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h4><p>题外话，说起这个周考作文，今天发给朱宇舟叔叔看，被干爆了他妈的，“……..给你讲了这么多堂作文课，我感觉的你的老毛病还是没有改啊……”，我天，微信语音里语气简直要杀人</p>
<p>我赶紧唯唯诺诺打太极，教科书操作，作文没学会就学会了太极，”啊，我开始看到的是辩论文，以为立意选择可以自由一点（自由个屁，要不是没时间谁愿意提起笔就写），就好像那个二模作文题目（趁他没看过杭州市二模题目，添加新项目掩人耳目，搞晕他！）…，所以这种辩论文，投稿什么的我立意就很容易偏（认错），那我大概67点钟重写一篇发给你（血亏，在家玩耍时间-50min）”</p>
<p>于是乎这是我重写的作文，考场上本来负重前行都想好了，但是真的要落笔的那一刻，我他妈直接揭竿而起，傻逼温家宝，傻逼四万亿，傻逼房价，傻逼内卷，傻逼炒房仔，还有楼下几个文科班的傻逼，站在人性的马里亚纳海沟疯狂地挥舞着道德的底裤，真就头发长见识短，写出来的话就是没脑子，那个黑板上的卑劣懦夫真的有把我笑到。于是反手一个抛却重负，淡然前行，这已经是二改的作文了，第一遍的高三猥琐小男孩作文就不打上来了，已经是12：00了，澡还没洗，这篇文章完成度估计才35%的样子，可能要写上个好几周了。</p>
<hr>
<p>《淡然前行，无需负重》<br>各位亲朋好友：</p>
<p>大家好！</p>
<p>我方的观点是：生命无需负重前行。</p>
<p>何为负重前行？背着沉甸甸的包裹向前走，也指背上沉甸甸的责任感像风雨中坚定的走去，而之所以无需负重前行，主要有两点。</p>
<p>希腊神话里丢卡利翁和比尔创造人类时，是拿石头扔到背后去，后来，罗利也咏了两句响亮的诗：“从此人心坚硬，任劳任怨，证明我们的身体本是岩石。”似乎说明人是要负重前行，才会真切实在的，可反观欧洲那冗长且黑暗的中世纪，人不但没有在那沉重的负担下稳步向前，反而是在折磨下失去了人的样子了，直到一千余年过去，米开朗琪罗、达芬奇等艺术家淡然地迈着轻盈的步伐，打开了思想解放的潮流，如同《呐喊》里一般大声疾呼“醒来”，人们抛却了重负，欧洲的艺术、近代科学才开始蓬勃的发展。因此，我方以为，大部分所谓“真切踏实”之感，只是把人囚禁于日趋一致的囚笼，不必要的重负只会成为人生活和思想的累赘，唯有淡然前行，生命才有光彩。</p>
<p>那必要的重负，又会给人带来什么样的问题呢？观照当今社会，我们总是对层出不穷的研究生频频自杀、高薪程序员深夜跳楼等社会惨剧痛心疾首，却没有深入的想过，是什么酿成了这种惨剧？我们无情的控诉研究室导师、无良互联网企业对学生、员工的变态要求、剥削压榨，可让受害者明知山有虎，还向虎山行的，酿成惨剧的根源，恐怕还是灵魂承担的重负，人追求真切，追求无愧于社会的要求、国家的希望、父母的培养，但当重负为灵魂所不能承受，生命自然便会凋零，倘若他们能够抛却那些重负，好好的审视自己当下的生活，淡然向前，自然也就把握好了生命的每一步。</p>
<p>正因如此，抛却重负前行，淡然前行，才在我们的生活中贡献了不可或缺的借鉴意义和指导思想。古往今来，凡能成大事者，无一不是抛却重负，淡然面对生活的，智谋如诸葛亮，给儿子留下了“淡泊以明智，宁静以致远的两句”，著名数学家吴文俊，也通过抛弃了数学界一直以来的“重负”和固有认知，创新的提出了计算机证明数学定理的“吴方法”。在当今这么一个生活快节奏，竞争激烈的环境里，抛却重负的思想，也早已在那些“佛系青年”身上开花结果，人均“丧”的时代里，他们面带微笑的像未来淡然行去。<br>综上所述，我方坚持生命无需负重的观点，淡然前行，才是最好的姿态。</p>
<hr>
<p>对，凭什么就要一昧写<strong>积极</strong>的文章，这种无脑的积极，无脑的正能量真的是要害死人，过犹不及啊，客观不能丢啊，所以阅卷老师不喜欢看也没办法，腿脚不利索，跪不下去（主要钱没到位，呸，分没到位），还是想站着把这分数给拿了，反正选择-1道，我还有机会嘿嘿。</p>
<h3 id="人格的交错"><a href="#人格的交错" class="headerlink" title="人格的交错"></a><del>人格的交错</del></h3><h3 id="挖坑"><a href="#挖坑" class="headerlink" title="挖坑"></a>挖坑</h3><p>这又是一个很大的话题，写完要天亮了，我搁着还想着等会是睡觉还是摸导数视频还是打LOL呢，先去把澡给洗了，然后下周回来趁杭杭没看见之前把负重那一段再改一下，我们不会有未来的，还是先把高考给应付咯，以后的事情以后说，他妈的0：17了，5500个字我也是牛逼，写完顿时放弃了以后当个兼职网文或者杂文作家的打算，洗澡洗澡。</p>
]]></content>
      <categories>
        <category>Think</category>
      </categories>
  </entry>
  <entry>
    <title>我可以说真话吗？2021年2月19日记</title>
    <url>/2021/04/17/%E6%9D%82%E6%8A%80/daily/2021.2.19/</url>
    <content><![CDATA[<p>小烦恼</p>
<a id="more"></a>

<p>刚刚和sh聊天，聊着聊着sh说晚上有人找他，我自然的问了一句谁啊，她说xxx和女朋友吵架了，到这里我就不应该再继续问是谁了，但是我问了，没脑子的表现，无论这是否是琐事，影不影响，至少是做错了，再继续问下去，按照sh的性格就和盘托出，然后我才意识到不对，不需要，更不应该去了解别人的隐私，对琐事好奇我向来是深恶痛绝的，这也是我讨厌敖翔身上的一点，似乎非要知道所有事情不可，这不是重点，重点是保持一个清醒的状态。</p>
]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>逆序对求解</title>
    <url>/2020/10/24/OI/%E9%A2%98%E8%A7%A3/%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P1908" target="_blank" rel="noopener">逆序对模板题</a></p>
<h2 id="归并排序求解逆序对："><a href="#归并排序求解逆序对：" class="headerlink" title="归并排序求解逆序对："></a>归并排序求解逆序对：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">500010</span>],c[<span class="number">500010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msort</span><span class="params">(<span class="keyword">int</span> b,<span class="keyword">int</span> e)</span></span>&#123; <span class="comment">// begin,end</span></span><br><span class="line">    <span class="keyword">if</span>(b==e)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(b+e)&gt;&gt;<span class="number">1</span>,i=b,j=mid+<span class="number">1</span>,k=b;</span><br><span class="line">    msort(b,mid),msort(mid+<span class="number">1</span>,e);</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=e)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j]) c[k++]=a[i++];</span><br><span class="line">        <span class="keyword">else</span> c[k++]=a[j++], ans+=mid-i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)c[k++]=a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=e)c[k++]=a[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=b;l&lt;=e;l++)a[l]=c[l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">    msort(<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树状数组求逆序对"><a href="#树状数组求逆序对" class="headerlink" title="树状数组求逆序对"></a>树状数组求逆序对</h2><p>树状数组怎么求逆序对？</p>
<p>根据数值建立树状数组，按照序列值从小到大排序，将数值对应的位置+1，那么<strong>有$a_i$与树状数组内比$a_i$大的数值都构成逆序对</strong>，考虑离散化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(a) ((a)&amp;(-a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c[N],r[N],n; <span class="comment">// c-树状数组,**r[i]表示原序列a[i]的位置**</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos,val;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.val==b.val?a.pos&lt;b.pos:a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> d)</span></span>&#123; <span class="keyword">for</span>(;p&lt;=n;p+=low(p)) c[p]+=d; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p;p-=low(p)) sum+=c[p];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i].val),a[i].pos=i;</span><br><span class="line">    <span class="built_in">std</span>::sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) r[a[i].pos]=i; <span class="comment">// 离散化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) add(r[i],<span class="number">1</span>),ans+=i-query(r[i]); <span class="comment">// 树状数组求逆序对</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>树状数组</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Race to 1 Again 数学期望</title>
    <url>/2020/10/24/OI/%E9%A2%98%E8%A7%A3/LightOJ1038/</url>
    <content><![CDATA[<p>给定一个$N$，N可以除以因子，问得到$1$需要的期望步数</p>
<a id="more"></a>

<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://vjudge.net/problem/LightOJ-1038" target="_blank" rel="noopener">题目</a>含义见上</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设$dp[i]$表示当前数字为$i$，变到$1$需要的期望步数</p>
<p>例：<br>$$dp[8] = \frac {(dp[1]+dp[2]+dp[4]+dp[8])}{4}+1$$</p>
<p>化简可得<br>$$dp[8] = \frac {(dp[1]+dp[2]+dp[4]+4)}{3}$$</p>
<p>这样就可以递推求解$dp[n]$</p>
<p>$$dp[n]=\frac {\Sigma_{i=1}^{k}dp[c[i]] + k}{k-1}$$</p>
<p>其中$k$是$n$的因子个数，$c[i]$是n的因子</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">double</span> f[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(f[x]) <span class="keyword">return</span> f[x];</span><br><span class="line">    <span class="keyword">double</span> tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>,i=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i*i&lt;x;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line">            tmp+=dp(i);</span><br><span class="line">            tmp+=dp(x/i);</span><br><span class="line">            num+=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i*i==x) tmp+=dp(i), num++;</span><br><span class="line">    tmp+=dp(<span class="number">1</span>),num++;</span><br><span class="line">    <span class="keyword">return</span> f[x]=(tmp+num+<span class="number">1</span>)/num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">int</span> Case=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">100010</span>;i++)&#123;</span><br><span class="line">        dp(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %.10lf\n"</span>,++Case,f[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P1352」没有上司的舞会</title>
    <url>/2020/10/24/OI/%E9%A2%98%E8%A7%A3/LGP1352%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A/</url>
    <content><![CDATA[<p>大佬们说这是树形DP基础题，蒟蒻想学树形DP…</p>
<a id="more"></a>
<h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>给定每个节点的快乐值</p>
<p>如果一个节点选择，那么它的儿子节点就不能再被选择</p>
<p>问选出的最大值是多少</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>每个节点只有选择或者不选择两种方式</p>
<p>设f[x][0]表示以x为根的树中，x不参会时最大的快乐值</p>
<p>则有：f[x][0]=sigma(max(f[s][0],f[s][1])); (s∈son[x])</p>
<p>f[x][1]表示参会时的最大分数</p>
<p>则有：f[x][1]=sigma(f[s][0])+a[i]; (s∈son[x])</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; son[<span class="number">6010</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">6010</span>][<span class="number">2</span>],v[<span class="number">6010</span>],h[<span class="number">6010</span>],n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="built_in">read</span>()&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="built_in">while</span>(!isdigit(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="built_in">while</span>(isdigit(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="built_in">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> dp(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    f[x][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    f[x][<span class="number">1</span>]=h[x];</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=son[x][i];</span><br><span class="line">        dp(y);</span><br><span class="line">        f[x][<span class="number">0</span>]+=<span class="built_in">max</span>(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>]);</span><br><span class="line">        f[x][<span class="number">1</span>]+=f[y][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">    <span class="comment">// freopen("in.in","r",stdin);</span></span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) h[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">        v[x]=<span class="number">1</span>; <span class="comment">// X has a father</span></span><br><span class="line">        son[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">if</span>(!v[i])&#123;</span><br><span class="line">            root=i;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp(root);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">max</span>(f[root][<span class="number">0</span>],f[root][<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P1082」同余方程</title>
    <url>/2020/10/24/OI/%E9%A2%98%E8%A7%A3/LGP1082%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/</url>
    <content><![CDATA[<p>线性同余方程的基础题</p>
<a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>求解$ax \equiv 1 (mod \  b)$的最小整数解</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以通过扩展欧几里得算法求解$ax+by=1$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Extend_GCD</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>,y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="keyword">int</span> d=Extend_GCD(b,a%b,x,y),tmp=x;</span><br><span class="line">    x=y,y=tmp-a/b*y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,x,y;</span><br><span class="line">    a=read(),b=read();</span><br><span class="line">    <span class="keyword">int</span> gcd=Extend_GCD(a,b,x,y);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(x+b)%b&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>乘法逆元</tag>
        <tag>扩展欧几里得</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P3366」最小生成树</title>
    <url>/2020/10/24/OI/%E6%A8%A1%E6%9D%BF/%5B%E6%A8%A1%E6%9D%BF%5D%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<p>此题有两种解法，详见博客——【学习笔记】最小生成树</p>
<a id="more"></a>

<h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal:"></a>Kruskal:</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* P3366 [模板]最小生成树 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;a.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[<span class="number">2000010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,ans,cnt;</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">5010</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x==fa[x]?x:find(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(e+<span class="number">1</span>,e+m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">    <span class="keyword">int</span> u,v,c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        u=find(e[i].u),v=find(e[i].v),c=e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;</span><br><span class="line">        ans+=c;</span><br><span class="line">        fa[u]=v;</span><br><span class="line">        <span class="keyword">if</span>(++cnt==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        e[i].u=read(),e[i].v=read(),e[i].w=read();</span><br><span class="line">    &#125;</span><br><span class="line">    Kruskal();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim:"></a>Prim:</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,cnt,ans;</span><br><span class="line"><span class="keyword">int</span> h[<span class="number">5010</span>],d[<span class="number">5010</span>];</span><br><span class="line"><span class="keyword">bool</span> v[<span class="number">5010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,val,nxt;</span><br><span class="line">&#125; e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v,e[cnt].val=c,e[cnt].nxt=h[u],h[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        x=read(),y=read(),z=read();</span><br><span class="line">        add(x,y,z),add(y,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//prim</span></span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">1</span>,tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) d[i]=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[<span class="number">1</span>];i;i=e[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].to;</span><br><span class="line">        d[y]=min(d[y],e[i].val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(++tot&lt;n)&#123;</span><br><span class="line">        <span class="keyword">int</span> minn=inf;</span><br><span class="line">        v[now]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(!v[i]&amp;&amp;minn&gt;d[i])</span><br><span class="line">                minn=d[i],now=i;</span><br><span class="line">        ans+=minn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[now];i;i=e[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> y=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(d[y]&gt;e[i].val&amp;&amp;!v[y]) d[y]=e[i].val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>最小生成树</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P5367」康托展开</title>
    <url>/2020/10/24/OI/%E6%A8%A1%E6%9D%BF/%5B%E6%A8%A1%E6%9D%BF%5D%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/</url>
    <content><![CDATA[<p>康托展开详见我的<a href="https://wyctstf.github.io/2019/10/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BA%B7%E6%8B%93%E5%B1%95%E5%BC%80/" target="_blank" rel="noopener">博文</a></p>
<a id="more"></a>

<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个序列的长度n和一组数列，保证这组数列是1-n的全排列中的一种，问这组排列在全排列中的字典序排名</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>此题用康托展开O(n^2)算法可以通过，但是鉴于严格情况下的数据以及限制，蒟蒻用的还是O(NlgN)的解法</p>
<p>一个优化思想是采用树状数组维护原数列中每一个a[i]的rank[i]的值，也就是维护区间和,其sum值就是rank值，用完之后add(i,-1)即可</p>
<p>先要O(n)维护一个阶乘的值</p>
<p>注意：不开long long见祖宗</p>
<p><del>用树状数组而不用线段树的原因：树状数组码量小</del></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">int</span> a[N],c[N],l[N],fac[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">        c[x]+=k,x+=l[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        t+=c[x];</span><br><span class="line">        x-=l[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fac[i]=fac[i<span class="number">-1</span>]*i%MOD,l[i]=i&amp;(-i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) add(i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=read();</span><br><span class="line">        ans=(ans+((sum(a[i])<span class="number">-1</span>)*fac[n-i])%MOD)%MOD;</span><br><span class="line">        add(a[i],<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数学</tag>
        <tag>树状数组</tag>
        <tag>康托展开</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P3367」并查集</title>
    <url>/2020/10/24/OI/%E6%A8%A1%E6%9D%BF/%5B%E6%A8%A1%E6%9D%BF%5D%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p>复习一波并查集的板子</p>
<a id="more"></a>

<p>想学习并查集的可以看<a href="https://oi-wiki.org/ds/dsu/" target="_blank" rel="noopener">这个</a>，UI漂亮</p>
<p>这次复习加了启发式合并以后跑的飞快</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N],fa[N],siz[N];</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="built_in">read</span>()&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="built_in">while</span>(!isdigit(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="built_in">while</span>(isdigit(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="built_in">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">find</span>(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    <span class="built_in">return</span> x==fa[x]?x:<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> merge(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=<span class="built_in">find</span>(x),fy=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="built_in">if</span>(fx==fy) <span class="built_in">return</span> ;</span><br><span class="line">    <span class="built_in">if</span>(siz[fx]&gt;siz[fy]) swap(fx,fy);</span><br><span class="line">    fa[fx]=fy;</span><br><span class="line">    siz[fy]+=siz[fx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">signed</span> main()&#123;</span><br><span class="line">    <span class="keyword">int</span> op,x,y;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i,siz[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        op=<span class="built_in">read</span>(),x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">if</span>(op==<span class="number">1</span>)</span><br><span class="line">            merge(x,y);</span><br><span class="line">        <span class="built_in">else</span></span><br><span class="line">            <span class="built_in">find</span>(x)==<span class="built_in">find</span>(y)?puts(<span class="string">"Y"</span>):puts(<span class="string">"N"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P3378」堆</title>
    <url>/2020/10/24/OI/%E6%A8%A1%E6%9D%BF/%5B%E6%A8%A1%E6%9D%BF%5D%E5%A0%86/</url>
    <content><![CDATA[<p>复习一波手写二叉堆的模板，以免初赛碰到没认出来导致场面一度尴尬</p>
<a id="more"></a>

<p>这篇<a href="https://www.cnblogs.com/henry-1202/p/9307927.html" target="_blank" rel="noopener">博客</a>写的还是不错的</p>
<h2 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h2><h3 id="插入："><a href="#插入：" class="headerlink" title="插入："></a>插入：</h3><p>将一个元素放到堆尾，比较和父节点的大小不断进行交换，一直到不满足条件为止</p>
<h3 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h3><p>直接输出堆顶，正常情况下我们都使用数组保存二叉树所以直接输出heap[1]即可</p>
<h3 id="取出堆顶元素："><a href="#取出堆顶元素：" class="headerlink" title="取出堆顶元素："></a>取出堆顶元素：</h3><p>把堆顶和堆尾交换，然后一直把堆顶向下交换即可</p>
<h2 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],n,siz;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    h[++siz]=x;</span><br><span class="line">    <span class="keyword">int</span> now=siz;</span><br><span class="line">    <span class="keyword">while</span>(now&gt;<span class="number">1</span> &amp;&amp; h[now]&lt;h[now&gt;&gt;<span class="number">1</span>])</span><br><span class="line">        swap(h[now],h[now&gt;&gt;<span class="number">1</span>]),now&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    swap(h[siz--],h[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>((now&lt;&lt;<span class="number">1</span>)&lt;=siz)&#123;</span><br><span class="line">        <span class="keyword">int</span> nxt=now&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>((nxt|<span class="number">1</span>)&lt;=siz&amp;&amp;h[nxt|<span class="number">1</span>]&lt;h[nxt]) nxt++;</span><br><span class="line">        <span class="keyword">if</span>(h[nxt]&lt;h[now]) swap(h[now],h[nxt]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        now=nxt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op,x;</span><br><span class="line">    n=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        op=read();</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            x=read();</span><br><span class="line">            ins(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;h[<span class="number">1</span>]&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>二叉堆</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P3388」割点</title>
    <url>/2020/10/24/OI/%E6%A8%A1%E6%9D%BF/%5B%E6%A8%A1%E6%9D%BF%5D%E5%89%B2%E7%82%B9/</url>
    <content><![CDATA[<p>割点的模板</p>
<a id="more"></a>

<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt,num,root,sum;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N];</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N*<span class="number">5</span>],nxt[N*<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> cut[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    ver[++cnt]=y,nxt[cnt]=head[x],head[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    dfn[x]=low[x]= ++num;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            tarjan(y);</span><br><span class="line">            low[x]=min(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;=dfn[x])&#123;</span><br><span class="line">                flag++;</span><br><span class="line">                <span class="comment">/* 如果不是根节点或者是根节点并且满足条件的y的num&gt;=2 */</span></span><br><span class="line">                <span class="keyword">if</span>(x!=root || flag&gt;<span class="number">1</span>) cut[x]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x]=min(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        x=read(),y=read();</span><br><span class="line">        <span class="keyword">if</span>(x==y) <span class="keyword">continue</span>;</span><br><span class="line">        add(x,y),add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) &#123;root=i,tarjan(i);&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cut[i]) sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cut[i]) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P3865」ST表</title>
    <url>/2020/10/24/OI/%E6%A8%A1%E6%9D%BF/%5B%E6%A8%A1%E6%9D%BF%5DST%E8%A1%A8/</url>
    <content><![CDATA[<p>倍增模板题之一</p>
<a id="more"></a>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定n个数和m个询问</p>
<p>每次询问有一个左右区间l,r</p>
<p>问区间内的最大值</p>
<p>要求每次查询时间复杂度为O(1)</p>
<h3 id="思路浅析"><a href="#思路浅析" class="headerlink" title="思路浅析"></a>思路浅析</h3><p>设f[i][j]表示表示以第i个数为起点，长度为2^j的区间[i,i+(2^j)-1]维护的信息，递推边界显然是f[i][0]=a[i]</p>
<p>在递推时，将区间长度成倍增长，则有f[i][j]=max/min{f[i][j-1],f[i+2^j][j-1]}</p>
<p>即把一个长度为2^j的区间分解成两部分来统计</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N],f[N][<span class="number">20</span>],lg[N]=&#123;<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=read();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i][<span class="number">0</span>]=a[i],lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lg[n];j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-(<span class="number">1</span>&lt;&lt;j)+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            f[i][j]=max(f[i][j<span class="number">-1</span>],f[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=lg[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> max(f[l][k],f[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ask</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        l=read(),r=read();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;query(l,r)&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    input();</span><br><span class="line">    pre();</span><br><span class="line">    ask();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机</title>
    <url>/2020/10/24/OI/%E6%A8%A1%E6%9D%BF/%5B%E6%A8%A1%E6%9D%BF%5DAC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<p>AC自动机是一种多模式串匹配算法，其时间复杂度与模式串总长度成正比</p>
<a id="more"></a>

<p>学习笔记的话推荐两篇比较好的blog</p>
<p><a href="https://oi.men.ci/acam-notes/" target="_blank" rel="noopener">menci</a></p>
<p><a href="https://oi-wiki.org/string/ac-automaton/" target="_blank" rel="noopener">oi-wiki</a></p>
<p>总的思想就是建立Trie树，然后利用KMP的思想建立失配指针指针，加快单个字符串查询速度，只要学会<strong>Trie</strong>和<strong>KMP</strong>，还是比较好理解的，这里直接给出洛谷基础模板题的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> AC &#123;</span><br><span class="line">    <span class="keyword">int</span> tot, e[N], fail[N], tr[N][<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; s[i]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!tr[u][s[i] - <span class="string">'a'</span>]) tr[u][s[i] - <span class="string">'a'</span>] = ++tot;</span><br><span class="line">            u = tr[u][s[i] - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        e[u]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) <span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tr[u][i]) fail[tr[u][i]] = tr[fail[u]][i], q.push(tr[u][i]);</span><br><span class="line">                <span class="keyword">else</span> tr[u][i] = tr[fail[u]][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; t[i]; i++) &#123;</span><br><span class="line">            u = tr[u][t[i] - <span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = u; j &amp;&amp; e[j] != <span class="number">-1</span>; j=fail[j]) &#123;</span><br><span class="line">                res += e[j], e[j] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>), AC::insert(s);;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    AC::build();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; AC::query(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>字符串</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2020/10/24/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>在解题时常需要维护一个数组的前缀信息，一旦涉及区间修改，一次操作就是O ( n )级别的，这里我们需要具有树形结构的树状数组来减小修改的操作数</p>
<a id="more"></a>
<h2 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h2><p>任意整数表示为二进制数时都是不同的，因此我们可以将x二进制分解，例如21可以分解成2^4+2^2+2^0，也就是说，[ 1 , x ]的区间可以分解成 log ( x )的小区间，以21为例：</p>
<ol>
<li>[ 1 , 2 ^ 4 ]的小区间</li>
<li>[ 2 ^ 4 + 1 , 2 ^ 4 + 2 ^ 2 ] 的小区间</li>
<li>[ 2 ^ 4 + 2 ^ 2 + 1 , 2 ^ 4 + 2 ^ 2 + 2 ^ 0 ]的小区间</li>
</ol>
<p>树状数组就是一种基于上述思想的数据结构，基本用途是维护序列的前缀信息，通过类似树形结构一样的分界区间，满足快速单点修改和区间和查询</p>
<h2 id="基本算法："><a href="#基本算法：" class="headerlink" title="基本算法："></a>基本算法：</h2><p>由上文可知，若区间结尾为R，那么区间长度就等于R的二进制分解下的最小的2的次幂，我们设为lowbit ( R )<br>对于给定序列A，建立数组c，其中c [ x ]保存序列A的区间[ x - lowbit ( x ) + 1 , x ]中的区间和<br><img src="https://img2018.cnblogs.com/blog/1576249/201908/1576249-20190801202345653-2102085685.png" alt></p>
<p>该结构满足以下性质：</p>
<ol>
<li>每个内部节点c [ x ]保存以它为根的子树中所有叶节点和</li>
<li>每个内部节点c [ x ]的子节点个数等于lowbit ( x )的位数</li>
<li>除了树根之外，每个内部节点的c [ x ]的父节点是c [ x + lowbit ( x ) ]</li>
<li>树的深度为O( logN  )</li>
</ol>
<p>由上图得出一个规律：<br><strong>C[ i ] = A[ i - 2 ^ k+1 ] + A[ i - 2 ^ k + 2 ] + … + A[ i ];   k为i的二进制中从最低位到高位连续零的长度，也就是lowbit ( i )</strong></p>
<h2 id="1-求lowbit-n"><a href="#1-求lowbit-n" class="headerlink" title="1.求lowbit( n )"></a>1.求lowbit( n )</h2><p>lowbit( n )表示取出非负整数n在二进制表示下最低位的1以及它后边的0构成的数值，<strong>lowbit ( n ) = n &amp; ( - n )</strong><br>证明过程：<br>设n &gt; 0,n的第k位是1,0 —- k - 1位都是0</p>
<ul>
<li><p>先将n取反，此时第k位变为0，0 —- k-1位为 1</p>
</li>
<li><p>n += 1，由于进位的关系，0 —- k位数值不变，n的第k+1位到最高位与原来相反</p>
</li>
<li><p>再进行按位&amp;操作，得到长度相同的部分，答案为 n &amp; (  ~ n + 1 )</p>
</li>
<li><p>在补码表示下 ~n = -1 - n，因此lowbit( n ) = n &amp; ( - n )</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="keyword">return</span> x &amp; (-n); &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-单点修改操作："><a href="#2-单点修改操作：" class="headerlink" title="2. 单点修改操作："></a>2. 单点修改操作：</h2><p>给序列中的某个数A[ x ] 加上y，同时维护正确的前缀和，根据上述的树形结构和性质，只有节点c[ x ]及其所有祖先节点保存的区间和包含A[ x ]，而任意一个节点的祖先至多有logN个，所以时间复杂度可以保证</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= N)</span><br><span class="line">    &#123;</span><br><span class="line">        c[x] += y; <span class="comment">/* 当前祖先节点更新 */</span></span><br><span class="line">        x += lowbit( x ); <span class="comment">/* 往上一祖先更新 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-查询前缀和："><a href="#3-查询前缀和：" class="headerlink" title="3. 查询前缀和："></a>3. 查询前缀和：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += c[x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-二维树状数组"><a href="#4-二维树状数组" class="headerlink" title="4. 二维树状数组"></a>4. 二维树状数组</h2><h3 id="单点修改："><a href="#单点修改：" class="headerlink" title="单点修改："></a>单点修改：</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">int update(int x, int y, int z)</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="built_in">i</span> = x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">i</span> &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        int <span class="built_in">j</span> = y;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">j</span> &lt;= m)</span><br><span class="line">        &#123;</span><br><span class="line">            c[<span class="built_in">i</span>][<span class="built_in">j</span>] += z;</span><br><span class="line">            <span class="built_in">j</span> += lowbit(<span class="built_in">j</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">i</span> += lowbit(<span class="built_in">i</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区间和统计："><a href="#区间和统计：" class="headerlink" title="区间和统计："></a>区间和统计：</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">int sum(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    int res = <span class="number">0</span>, <span class="built_in">i</span> = x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">i</span> &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        int <span class="built_in">j</span> = y;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">j</span> &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res += c[<span class="built_in">i</span>][<span class="built_in">j</span>];</span><br><span class="line">            <span class="built_in">j</span> -= lowbit(<span class="built_in">j</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">i</span> -= lowbit(<span class="built_in">i</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-区间修改-amp-单点查询（差分数组）："><a href="#5-区间修改-amp-单点查询（差分数组）：" class="headerlink" title="5. 区间修改 &amp; 单点查询（差分数组）："></a>5. 区间修改 &amp; 单点查询（差分数组）：</h2><p>当一段区间需要修改的时候，单纯的O(m)遍历是无法满足复杂度要求的，最坏情况可能都不如普通数组有效，因此我们需要一个技巧<strong>差分建树</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">50005</span>] = &#123;<span class="number">0</span>&#125;, c[<span class="number">50005</span>]; <span class="comment">//对应原数组和树状数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//在i位置加上k</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += k;</span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//求D[1 - i]的和，即A[i]值</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res += c[i];</span><br><span class="line">        i -= lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        updata(i, a[i] - a[i - <span class="number">1</span>]); <span class="comment">//输入初值的时候，也相当于更新了值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[x,y]区间内加上k</span></span><br><span class="line">    updata(x, k);      <span class="comment">//A[x] - A[x-1]增加k</span></span><br><span class="line">    updata(y + <span class="number">1</span>, -k); <span class="comment">//A[y+1] - A[y]减少k</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询i位置的值</span></span><br><span class="line">    <span class="keyword">int</span> sum = getsum(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-区间修改、区间查询"><a href="#6-区间修改、区间查询" class="headerlink" title="6. 区间修改、区间查询"></a>6. 区间修改、区间查询</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">50005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum1[<span class="number">50005</span>]; <span class="comment">//(D[1] + D[2] + ... + D[n])</span></span><br><span class="line"><span class="keyword">int</span> sum2[<span class="number">50005</span>]; <span class="comment">//(1*D[1] + 2*D[2] + ... + n*D[n])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = i; <span class="comment">//因为x不变，所以得先保存i值</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        sum1[i] += k;</span><br><span class="line">        sum2[i] += k * (x - <span class="number">1</span>);</span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//求前缀和</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, x = i;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res += x * sum1[i] - sum2[i];</span><br><span class="line">        i -= lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        updata(i, a[i] - a[i - <span class="number">1</span>]); <span class="comment">//输入初值的时候，也相当于更新了值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[x,y]区间内加上k</span></span><br><span class="line">    updata(x, k);      <span class="comment">//A[x] - A[x-1]增加k</span></span><br><span class="line">    updata(y + <span class="number">1</span>, -k); <span class="comment">//A[y+1] - A[y]减少k</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//求[x,y]区间和</span></span><br><span class="line">    <span class="keyword">int</span> sum = getsum(y) - getsum(x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="That’s-all"><a href="#That’s-all" class="headerlink" title="That’s all."></a>That’s all.</h1>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>学习笔记</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2020/10/24/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<p>点开洛谷模板题一看原来是抄了题解，吓得赶紧重新学习</p>
<a id="more"></a>
<h1 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h1><p>最小生成树(MST)是指在一个节点数量为n的<strong>无向图</strong>中的一个由<strong>n-1</strong>条边构成的<strong>连通子图</strong>并且<strong>边权和最小</strong></p>
<h1 id="Kruskal算法："><a href="#Kruskal算法：" class="headerlink" title="Kruskal算法："></a>Kruskal算法：</h1><h2 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h2><p>对所有边进行排序，用并查集维护连通性，从小到大选择边，判断是否构成一个环，如果不是则加入，否则放弃</p>
<h2 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h2><ol>
<li><p>建立并查集，每个节点各自构成一个集合</p>
</li>
<li><p>所有边的边权按照权值从小到大排序，依次扫描每一条边(x,y,z)</p>
</li>
<li><p>如果x,y属于同一集合，那么忽略这条边</p>
</li>
<li><p>否则合并x,y，把z累加到答案中</p>
</li>
</ol>
<p>所有的边扫描完成之后，就构成了一棵MST</p>
<p>时间复杂度为O(m logm)</p>
<p>据说适用于稀疏图</p>
<h1 id="Prim算法："><a href="#Prim算法：" class="headerlink" title="Prim算法："></a>Prim算法：</h1><h2 id="算法思路：-1"><a href="#算法思路：-1" class="headerlink" title="算法思路："></a>算法思路：</h2><ul>
<li><p>最初，确定节点1在MST中</p>
</li>
<li><p>和Dijkstra相似(不知道的可以略过这句话)，以1为当前节点不断找到与当前节点距离最短的节点，使用一个v[N]数组进行标记，如果没有到过该节点，那么就收入到MST中,ans+=dis[now][to]</p>
</li>
<li><p>采用一个d[N]数组记录当前节点到各个节点的距离值，在收入节点与当前节点的转移中不断更新</p>
</li>
</ul>
<p>所有的点被收入之后，就生成了一棵MST</p>
<p>时间复杂度为O(N^2)，可以通过堆优化降低复杂度到O(m logn)，但是编程复杂度就不如Kruskal优秀，因此适用于稠密图，尤其是完全图的最小生成树求解</p>
<p>模板题详见博客——【洛谷 P3366】【模板】最小生成树(持续更新ing)</p>
]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>算法模板</tag>
        <tag>学习笔记</tag>
        <tag>最小生成树</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>康托展开</title>
    <url>/2020/10/24/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BA%B7%E6%8B%93%E5%B1%95%E5%BC%80/</url>
    <content><![CDATA[<p>康托展开用于求解一个全排列在所有全排列中的排名</p>
<a id="more"></a>

<h2 id="举栗"><a href="#举栗" class="headerlink" title="举栗"></a>举栗</h2><p>对于1-4的一个全排列{1，2，3，4}和{4，3，2，1}，我们知道，就字典序而言，第一个排列是全排列里的第一个，后者是最后一个排列</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩</p>
<p>它的实质是计算当前排列在所有字典序由小到大全排列中的名次，是可逆的，也就是可以根据排名而求出这个排列</p>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>给定一个数列a[n]</p>
<blockquote>
<p><strong>X=A[0] * (n-1)!+A[1] * (n-2)!+…+A[n-1] * 0!</strong></p>
</blockquote>
<p>A[i]指的是位于位置i后面的数小于a[i]值的个数</p>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释:"></a>解释:</h2><p>以{2，3，4，1}来说明</p>
<ol>
<li><p>初始字典序为0</p>
</li>
<li><p>第一位是2，那么以1打头的所有全排列一定排在这个全排列之前，rank=rank+1*3！，3！指的是剩下的数有3!的排列情况</p>
</li>
<li><p>第二位是3，那么与1、2作为第二位的所有全排列就一定在这个之前，但已经让2打头了，不需要再考虑2占第二位的情况，只需要计算1占第二位的情况，rank+=1*2!</p>
</li>
<li><p>第三位是4，同理rank+=1*1!</p>
</li>
<li><p>最后一位就不用判定了，当然为了格式也可以有rank+=0*0!</p>
</li>
<li><p>最后答案+1即可，因为第一个排列的排名是1</p>
</li>
</ol>
<p>在步骤3中，可以看到，实际考虑的情况是比3小并且位置没有固定&lt;==&gt;之前的序列里没有出现&lt;==&gt;出现在之后的序列里，那么真正干扰的也就是a[i]在i+1—n个数内的排名</p>
<p>至此公式解释完毕</p>
<blockquote>
<h3 id="模板题-【洛谷P5367】康托展开"><a href="#模板题-【洛谷P5367】康托展开" class="headerlink" title="模板题-【洛谷P5367】康托展开"></a><a href="https://www.luogu.org/problem/P5367" target="_blank" rel="noopener">模板题-【洛谷P5367】康托展开</a></h3></blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p>WXY教练PPT中的关于康拓展开的一页</p>
</li>
<li><p>网上一位大佬的<a href="https://blog.csdn.net/ajaxlt/article/details/86544074" target="_blank" rel="noopener">博文</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>「单调队列」</title>
    <url>/2020/10/24/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="例题引入"><a href="#例题引入" class="headerlink" title="例题引入"></a>例题引入</h2><p>给定一个长度为N的序列，从中找出一段长度不超过M的连续子序列，使得和最大</p>
<h2 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h2><p>维护一个前缀和$s[i]$，枚举左右端点$j$，$i$，使得$s[i]-s[j-1]尽可能地大$，时间复杂度为O(nm)</p>
<p>发现对于每一个$k \in [j,i]，如果s[k]&lt;=s[j]$，那么相比$j$，$k$显然是一个更好的选择</p>
<p>不难发现，对于每一个右端点$i$，可能成为最优策略的左端点<strong>策略集合</strong>一定是一个<strong>下标位置递增，维护的值也单调</strong>，此处就是维护前缀和单调<strong>递增</strong>的情况</p>
<p>考虑<strong>使用一个队列维护左端点的下标值</strong>，对应当前队头的决策<strong>不满足条件</strong>(此处为超出限定的长度M)，我们才<strong>退而求其次</strong>的选择一个次优解，这就是原题中维护前缀和递增的原因</p>
<p>可以证明，对于每个$q.front()$，对之后长度不超过M的右端点的最优左端点都成立</p>
<p>随着右端点向后扫描，对每个$i$执行下述三个操作：</p>
<ol>
<li>判断队头决策与$i$的距离是否超出M，若超出则出队</li>
<li>此时队头决策就是右端点为$i$时，对左端点$j$的最优选择</li>
<li>不断删除队尾决策，直到$s[q.tail()]\leq s[i]$，i作为一个新的决策入队</li>
</ol>
<h3 id="如何理解第三步操作？"><a href="#如何理解第三步操作？" class="headerlink" title="如何理解第三步操作？"></a>如何理解第三步操作？</h3><p>对于$i$之前的序列，都得到过最优解，那么他们也可以作为左端点备用选择，放到队尾，因为维护了一个单调性队列，可以确保轮到i作为队头决策时，$i$是最优选择</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">while</span>(<span class="selector-tag">s</span><span class="selector-attr">[q.front()]</span>&gt;<span class="selector-tag">s</span><span class="selector-attr">[i]</span>) <span class="selector-tag">q</span><span class="selector-class">.pop_back</span>();</span><br><span class="line"><span class="selector-tag">q</span><span class="selector-class">.push_back</span>(<span class="selector-tag">i</span>)</span><br></pre></td></tr></table></figure>

<p>上述代码就维护了单调性</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define int long long</span></span><br><span class="line">using namespace std;</span><br><span class="line">const <span class="keyword">int</span> N=<span class="number">1</span>e5+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,<span class="keyword">m</span>,front,back,ans;</span><br><span class="line"><span class="keyword">int</span> a[N],<span class="string">q[N]</span>,<span class="keyword">s</span>[N];</span><br><span class="line">signed main()&#123;</span><br><span class="line">    scanf(<span class="string">"%lld%lld"</span>,&amp;n,&amp;<span class="keyword">m</span>);</span><br><span class="line">    front=back=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        scanf(<span class="string">"%lld"</span>,a+i),<span class="keyword">s</span>[i]=<span class="keyword">s</span>[i-<span class="number">1</span>]+a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(front&lt;=back &amp;&amp; <span class="keyword">s</span>[<span class="string">q[back]</span>-<span class="number">1</span>]&gt;<span class="keyword">s</span>[i])&#123;</span><br><span class="line">            back--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">q[++back]</span>=i-<span class="number">1</span>;</span><br><span class="line">        // cout&lt;&lt;<span class="string">q[back]</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">        ans=max(ans,<span class="keyword">s</span>[i]-<span class="keyword">s</span>[<span class="string">q[back]</span>-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span>(i-<span class="string">q[front]</span>&gt;<span class="keyword">m</span>) front++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单调性参考例题："><a href="#单调性参考例题：" class="headerlink" title="单调性参考例题："></a>单调性参考例题：</h2><ul>
<li><a href="https://www.luogu.org/problem/P1886" target="_blank" rel="noopener">P1886 滑动窗口</a></li>
<li><a href="https://www.luogu.org/problem/P2422" target="_blank" rel="noopener">P2422 良好的感觉</a></li>
</ul>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>初级线段树</title>
    <url>/2020/10/24/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<blockquote>
<p>线段树是一种基于分治思想的二叉树结构，用于在区间上的信息统计。与按照二进制位进行区间划分的树状数组相比，线段树是一种更加通用的数据结构；</p>
</blockquote>
<a id="more"></a>
<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><ol>
<li>线段树的每一个节点都代表一个区间</li>
<li>线段树具有唯一的根节点，代表的区间是整个统计范围([1,N])</li>
<li>线段树的每个叶节点都代表一个长度为1的元区间[x,x]</li>
<li>对于每个<strong>内部节点[l,r],它的左儿子节点是[l,mid]，右儿子节点是[mid+1,r]，其中mid为floor((l+r)/2)</strong></li>
<li>使用线段树统计，必须满足信息分配原理<ul>
<li>满足区间加法：<ul>
<li>区间求和</li>
<li>区间最大公因数</li>
<li>区间最值</li>
</ul>
</li>
<li>不满足：<ul>
<li>区间众数</li>
<li>01序列最长连续0</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="source/images/SegmentTree.png" alt></p>
<h2 id="相关操作："><a href="#相关操作：" class="headerlink" title="相关操作："></a>相关操作：</h2><h3 id="建树和维护"><a href="#建树和维护" class="headerlink" title="建树和维护:"></a>建树和维护:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans[N&lt;&lt;<span class="number">2</span>]; <span class="comment">// 空间开到4倍大小，因为总共有n*2-1个节点，叶节点还需要支配两个没有意义但有实际作用的节点，一共需要4*n-1个节点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>;&#125; <span class="comment">// inline 排除无效信息,ls &lt;--&gt; left son</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;&#125; <span class="comment">// 位运算加速</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up_sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 维护区间和</span></span><br><span class="line">    t[x]=t[ls(x)]+t[rs(x)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up_max</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 维护区间最值</span></span><br><span class="line">    t[x]=max(t[ls(x)],t[rs(x)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;ans[x]=a[x];<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 向下递归建树</span></span><br><span class="line">    build(ls(x),l,mid);</span><br><span class="line">    build(rs(x),mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="comment">// 回溯时通过子节点向上维护父亲节点</span></span><br><span class="line">    push_up_max(x);</span><br><span class="line">    push_up_sum(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单点修改："><a href="#单点修改：" class="headerlink" title="单点修改："></a>单点修改：</h3><p>形如一条”C x v”的指令，表示把a[x]的值修改为y;</p>
<p>在线段树中，根节点是执行各种指令的入口。我们需要从根节点出发，我们从根节点出发，递归找到代表区间[x,x]的叶节点，然后从下向上更新[x,x]以及它的所有的祖先节点上保存的信息，时间复杂度为O(nlogn)</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">void change(<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> v)&#123; <span class="comment">// r-root</span></span><br><span class="line">    <span class="keyword">if</span>(t[<span class="keyword">ls</span>(p)]==t[rs(p)])&#123;</span><br><span class="line">        a[r]=v;<span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(a[<span class="keyword">ls</span>(r)]+a[rs(r)])&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) change(<span class="keyword">ls</span>(r),x,v);</span><br><span class="line">    <span class="keyword">else</span> change(rs(r),x,v);</span><br><span class="line">    push_up_max(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区间修改："><a href="#区间修改：" class="headerlink" title="区间修改："></a>区间修改：</h3><p>如果像单点修改一样，那么<strong>总时间复杂度为O(n^2logn)，甚至不如O(n^2)</strong>，因此我们引入一个操作——<strong>懒标记</strong></p>
<p>懒标记的作用是记录每次每个节点要更新的值，记为delta，但是全记录的话复杂度就会爆炸，所以需要传递式记录，如果后续没有查询操作，那么就不着急全记录，可以等待信息的整合之后，到了要查询的情况再下传至底部，再重新上传更新所统计信息(区间和、区间最值等等)</p>
<ul>
<li><p>此过程可视为push_up的反向思路，但不是反向操作</p>
</li>
<li><p>若整个区间都被操作，那么记录在公共祖先节点上，如果只修改了一部分，那么就记录在这部分的祖先节点上面，如果只修改了自己，那么就只改变自己</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123; <span class="comment">//打标记，更新信息，以k为参数区间修改</span></span><br><span class="line">    tag[p]+=k;</span><br><span class="line">    ans[p]=ans[p]+k*(r-l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123; <span class="comment">//标记下传</span></span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    f(ls(p),l,mid,tag[p]);</span><br><span class="line">    f(rs(p),mid+<span class="number">1</span>,r,tag[p]);</span><br><span class="line">    tag[p]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> k)</span></span>&#123; <span class="comment">//x,y为待修改区间,k为修改权值</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123; <span class="comment">//如果完全覆盖</span></span><br><span class="line">        ans[p]+=k*(r-l+<span class="number">1</span>);</span><br><span class="line">        tag[p]+=k; <span class="comment">//需要下传，打标记</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(p,l,r); <span class="comment">//标记下传</span></span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>（x&lt;=mid) change(x,y,l,mid,ls(p),k); <span class="comment">// 如果左区间超过当前区间的左区间</span></span><br><span class="line">    <span class="keyword">if</span>（y&gt;mid) change(x,y,mid+<span class="number">1</span>,r,rs(p),k); <span class="comment">// 同上</span></span><br><span class="line">    push_up(p); <span class="comment">//更新信息，上传</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区间查询："><a href="#区间查询：" class="headerlink" title="区间查询："></a>区间查询：</h3><p>继续采用分块的思想，简单易懂</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> P)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y) <span class="keyword">return</span> ans[p]; <span class="comment">//如果完全覆盖，那么返回所有的信息</span></span><br><span class="line">    push_down(p,l,r); <span class="comment">// 标记下传，因为信息的整合，所以可以有效节省时间</span></span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) res+=query(x,y,l,mid,ls(p)); <span class="comment">// 分左右区间查询</span></span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) res+=query(x,y,mid+<span class="number">1</span>,r,rs(p));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里我们就可以过掉：</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P3372" target="_blank" rel="noopener">[洛谷 P3372]线段树1</a></p>
</blockquote>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><blockquote>
<ul>
<li>《算法竞赛进阶指南》</li>
<li><a href="https://www.luogu.org/blog/pks-LOVING/senior-data-structure-qian-tan-xian-duan-shu-segment-tree" target="_blank" rel="noopener">洛谷日报#4 浅谈线段树</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>乘法逆元</title>
    <url>/2020/10/24/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/</url>
    <content><![CDATA[<p>顾名思义，就是模意义下乘法运算的逆元</p>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如果一个线性同余方程$ax\equiv 1\ (mod \ b)$，则$x$称为$a$对$b$的逆元，记作$a^{-1}$</p>
<h2 id="Section1-扩欧"><a href="#Section1-扩欧" class="headerlink" title="Section1 - 扩欧"></a>Section1 - 扩欧</h2><blockquote>
<p>本质和解线性同余方程一样</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123; <span class="comment">// 扩欧可以返回ax+by=gcd(a,b)的一组整数解</span></span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>,y=<span class="number">0</span>;<span class="keyword">return</span> a; <span class="comment">// 返回特解x=1,y=0并正常的求解gcd</span></span><br><span class="line">    <span class="keyword">int</span> res=exgcd(b,a%b,x,y);</span><br><span class="line">    <span class="keyword">int</span> tmp=x;</span><br><span class="line">    x=y,t=tmp-(a/b)*y;</span><br><span class="line">    <span class="keyword">return</span> res; <span class="comment">// 同时返回gcd值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">exgcd_inv</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d,x,y;</span><br><span class="line">    d=exgcd(a,n,x,y);</span><br><span class="line">    <span class="keyword">return</span> d==<span class="number">1</span>?(x+n)%n:<span class="number">-1</span>; <span class="comment">// -1表示没有乘法逆元</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Section2-费马小定理"><a href="#Section2-费马小定理" class="headerlink" title="Section2 - 费马小定理"></a>Section2 - 费马小定理</h2><blockquote>
<p>当$p$为质数时(使用条件)，有$a^{p-1}\equiv 1 \ (mod \ p)$，可变为$a*a^{p-2} \equiv 1 \ (mod \ p)$，此时$a^{p-2}就是$a$对$p$的乘法逆元$</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">QuickPow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=b;</span><br><span class="line">    <span class="keyword">for</span>(;a;a&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&amp;<span class="number">1</span>)</span><br><span class="line">            ans=(ans*b%p);</span><br><span class="line">        ans=ans*ans%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fermat_inv</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QuickPow(a,n<span class="number">-2</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种线性筛逆元的解法，等哪天有时间补上，先复习初赛续命…</p>
<hr>
<p><a href="https://www.luogu.org/problem/P1082" target="_blank" rel="noopener">模板1</a></p>
<p><a href="https://www.luogu.org/problem/P3811" target="_blank" rel="noopener">模板2</a></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>数论</tag>
        <tag>乘法逆元</tag>
        <tag>扩展欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title>基础二分图</title>
    <url>/2020/10/24/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>二分图是一种常见的图论模型</p>
<a id="more"></a>

<h2 id="二分图基础知识"><a href="#二分图基础知识" class="headerlink" title="二分图基础知识"></a>二分图基础知识</h2><ul>
<li><p>二分图可以分成左右两个点集，所有的边都连着$U<br>$到$V$</p>
</li>
<li><p>二分图中没有奇环</p>
</li>
<li><p>匹配：是一些边的集合，任意两条边没有公共顶点</p>
</li>
<li><p>最大匹配：所有匹配中边数最多的匹配</p>
</li>
<li><p>完美匹配：所有的点都在匹配中</p>
</li>
<li><p>二分图最大匹配算法：匈牙利算法</p>
</li>
<li><p>匹配点：盖点|非匹配点：未盖点</p>
</li>
<li><p>匹配边、匹配点：在一个匹配中的边和点</p>
</li>
</ul>
<h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>假设已经有了一个匹配，比较和最大匹配的差距</p>
<p>连接两端未盖的匹配边</p>
<p>然后在原图基础上找增广路，<strong>找不到说明是最大匹配</strong></p>
<p>从一侧的未盖点走增广路，也就是匹配边|非匹配边|匹配边|非匹配边的走法，如果可以走到另一侧的未盖点，那么就找到了一条增广路</p>
<p><strong>已经匹配的点永远不会退出匹配</strong>，只会更换匹配</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未匹配的增广路</span></span><br><span class="line"><span class="meta">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;er<span class="string">'fen'</span>tu</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1010</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; edge[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> mx[N], my[M];</span><br><span class="line"><span class="keyword">bool</span> visy[M];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span>(<span class="params"><span class="keyword">int</span> x</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= m; t++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[x][t] == <span class="number">1</span> &amp;&amp; !visy[t]) &#123;</span><br><span class="line">            visy[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(my[t] == <span class="number">-1</span> || dfs(my[t]) ) &#123;</span><br><span class="line">                mx[x] = t;</span><br><span class="line">                my[t] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_match</span>(<span class="params"><span class="keyword">int</span> n, <span class="keyword">int</span> m</span>)</span> &#123;</span><br><span class="line">    fill(mx, mx + n, <span class="number">-1</span>);</span><br><span class="line">    fill(my, my + m, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        fill(visy, visy + m, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (dfs(i)) &#123;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    x = y;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">    edge[x].push_back(y);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="洛谷模板：二分图匹配"><a href="#洛谷模板：二分图匹配" class="headerlink" title="洛谷模板：二分图匹配"></a>洛谷模板：<a href="https://www.luogu.org/problem/P3386" target="_blank" rel="noopener">二分图匹配</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, e, f[N]; <span class="comment">// f[i]表示对于一个右侧端点的左端匹配点</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;N&gt; vis; <span class="comment">// bitset优化常数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : edge[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[v] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!f[v] || dfs(f[v])) &#123; <span class="comment">// 增广</span></span><br><span class="line">            f[v] = u;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;e);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= e; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="keyword">if</span>(u &gt; n || v &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">        edge[u].push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        vis.reset();</span><br><span class="line">        ans += dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题：飞行员配对染色方案"><a href="#例题：飞行员配对染色方案" class="headerlink" title="例题：飞行员配对染色方案"></a>例题：<a href="https://www.luogu.org/problem/P2756" target="_blank" rel="noopener">飞行员配对染色方案</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N * N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt, ans;</span><br><span class="line"><span class="keyword">int</span> h[N], ver[M], nxt[M];</span><br><span class="line"><span class="keyword">int</span> mx[N], my[N];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;N&gt; vis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ver[++cnt] = v, nxt[cnt] = h[u], h[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!my[y] || dfs(my[y])) &#123;</span><br><span class="line">            my[y] = u, mx[u] = y;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n, u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span> &amp;&amp; v == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        add(u, v), add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) vis.reset(), ans += dfs(i);</span><br><span class="line">    m==<span class="number">0</span> ? <span class="built_in">puts</span>(<span class="string">"Nod Solution"</span>) : <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span>(mx[i]) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i, mx[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分图最小点覆盖"><a href="#二分图最小点覆盖" class="headerlink" title="二分图最小点覆盖"></a>二分图最小点覆盖</h2><p>给定一个二分图，求在节点上最少安排几个守卫使得所有的边都能被监控到，一个节点可以经过所有经过这个点的边</p>
<h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><blockquote>
<p>二分图最小点覆盖等于二分图最大匹配包含的边数</p>
</blockquote>
<ul>
<li>证明</li>
</ul>
<p>最大匹配是原二分图边集的一个子集，并且所有边不相交，所以至少要从每条匹配边中选出一个端点。</p>
<p>因此，最小点覆盖包含的点数不可能小于最大匹配包含的边数，如果能对任意二分图构造出一组点覆盖，那么定理就得证</p>
<ul>
<li><p>构造方法</p>
<ol>
<li>求出二分图最大匹配</li>
<li>从每个左部非匹配点出发，执行DFS找增广路，标记访问过的节点</li>
<li>取左部未被标记的点、右部被标记的点，就得到了二分图最小点覆盖</li>
</ol>
</li>
<li><p>证明</p>
<ol>
<li>匹配边一定被覆盖</li>
<li>不存在连接两个非匹配点的边，否则存在增广路</li>
<li>连接左部非匹配点i、右部匹配点j的边：j一定被访问，这样的边被覆盖</li>
<li>连接左部匹配点i，右部非匹配点j的边同理</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>Tarjan杂谈</title>
    <url>/2020/10/24/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Tarjan/</url>
    <content><![CDATA[<h1 id="Part1-无向图的割点-割边"><a href="#Part1-无向图的割点-割边" class="headerlink" title="$Part1$ 无向图的割点\割边"></a>$Part1$ 无向图的割点\割边</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>给定无向图$G \in (V,E)$</p>
<p>若对于$x \in V$，从图中删去$x$以及所有与$x$关联的边之后，$G$分裂成两个及以上不相连的子图，则称$x$是$G$的<strong>割点</strong></p>
<p>若对于$e \in E$，从图中删去$e$之后，$G$分裂成两个不相连的子图，则称$e$为$G$的<strong>桥或割边</strong></p>
<hr>
<p>Tarjan基于无向图的DFS</p>
<hr>
<h2 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h2><ul>
<li><p>时间戳</p>
<p>  在图的DFS过程中，按照每个节点第一次被访问的时间顺序一次给予$1 \to N$的标，该标记被称为 $时间戳$，记为dfn[x]</p>
</li>
<li><p>搜索树</p>
<p>  从无向图中任选一个节点出发DFS，每个节点只访问一次，所有发生递归的边构成一棵树，称为<strong>无向连通图的搜索树</strong>，一般无向图的各个连通块的搜索树构成无向图的<strong>搜索森林</strong></p>
</li>
<li><p>追溯值</p>
<blockquote>
<p>low[x]表示节点$x$的追溯值</p>
</blockquote>
<p>  设$subtree(x)$表示搜索树中以$x$为根节点的子树，$low[x]$为以下节点的dfn的最小值</p>
<ol>
<li><p>$subtree(x)$中的节点</p>
</li>
<li><p>通过一条不在搜索树上的边，能够到达$subtree(x)$的节点</p>
<p>计算$low[x]$时先令$low[x]=dfn[x]$，然后考虑每条从$x$出发的边$(x,y)$:</p>
</li>
<li><p>若在搜索树上$x$是$y$的父节点，则令$low[x]\ = min(low[x],low[y])$</p>
</li>
<li><p>若无向边$(x,y)$不是搜索树上的边，则令$low[x]=min(low[x],dfn[y])$</p>
</li>
</ol>
</li>
</ul>
<h2 id="割边的判定："><a href="#割边的判定：" class="headerlink" title="割边的判定："></a>割边的判定：</h2><blockquote>
<p>无向边$(x,y)$是桥，当且仅当搜索树上存在x的一个子结点y，满足:<br>$$dfn[x]&lt;low[y]$$</p>
</blockquote>
<h2 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h2><p>根据定义，$dfn[x]&lt;low[y]$说明从$subtree(y)$出发，在不经过$(x,y)$的前提下，不管走哪条边，都无法到达$x$或比$x$更早访问的节点。</p>
<p>若把$(x,y)$删除，$subtree(y)$封闭</p>
<h2 id="一些问题以及解决方法"><a href="#一些问题以及解决方法" class="headerlink" title="一些问题以及解决方法"></a>一些问题以及解决方法</h2><p>遍历的是无向图，所以从每个节点$x$出发，总能访问到它的父节点$fa$,$fa$是搜索树上的边，但不是x的子节点，故不能用$fa$的时间来更新$low[x]$</p>
<p>但是仅仅记录每个节点的父节点，将无法处理重边，当$x$与$fa$之间有多条边时，$(x,fa)$一定不是桥，在重边中，只有一条算是“搜索树上的边”，其他的几条都不算。</p>
<p>故有重边的时候，$dfn[fa]$可以用来更新$low[x]$</p>
<p>一个比较好的解决方法是：</p>
<p>改为记录“递归进入每个节点的边的编号”。编号可理解为在邻接表中存储的边的下标的位置</p>
<p>这里需要用到“成对变换”的技巧，也就是如果进入了编号为$x$的边，则忽略编号为$x \ xor \ 1$的边</p>
<p>通过其他的边计算$low[x]$即可</p>
<p>下面给出代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,tot,num;</span><br><span class="line"><span class="keyword">int</span> h[N],ver[N&lt;&lt;<span class="number">1</span>],nxt[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N];</span><br><span class="line"><span class="keyword">bool</span> bridge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> in_edge)</span></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++num; <span class="comment">// 初始化low[x]=dfn[x]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            tarjan(y,i);</span><br><span class="line">            low[x]=min(low[x],low[y]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;dfn[x])</span><br><span class="line">                bridge[i]=bridge[i^<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i!=(in_edge^<span class="number">1</span>))</span><br><span class="line">            low[x]=min(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        x=read(),y=read(),add(x,y),add(y,x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) tarjan(i,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;tot;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bridge[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ver[i^<span class="number">1</span>],ver[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="割点的判定："><a href="#割点的判定：" class="headerlink" title="割点的判定："></a>割点的判定：</h2><p>若$x$不是搜索树的根节点($DFS$起点)，则$x$是割点当且仅当搜索树上存在$x$的一个子节点$y$，满足：<br>$$dfn[x]\  \leq \ low[y]$$</p>
<p>特别的，若$x$是搜索树的根节点，则$x$是搜索树的根节点，则$x$是割点当且仅当搜索树上存在至少两个子节点$y1,y2$满足上述条件</p>
<h2 id="请自己尝试证明，方法与割边证明过程相似"><a href="#请自己尝试证明，方法与割边证明过程相似" class="headerlink" title="请自己尝试证明，方法与割边证明过程相似"></a>请自己尝试证明，方法与割边证明过程相似</h2><h2 id="P3388-模板-割点-代码实现："><a href="#P3388-模板-割点-代码实现：" class="headerlink" title="P3388[模板]割点 代码实现："></a><a href="https://www.luogu.org/problem/P3388" target="_blank" rel="noopener">P3388[模板]割点</a> 代码实现：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,rt; <span class="comment">// rt--root</span></span><br><span class="line"><span class="keyword">int</span> cnt,num;</span><br><span class="line"><span class="keyword">int</span> h[N],ver[N&lt;&lt;<span class="number">1</span>],nxt[N&lt;&lt;<span class="number">1</span>]; <span class="comment">// 邻接表建图</span></span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N]; <span class="comment">// 相应的dfn、追溯值</span></span><br><span class="line"><span class="keyword">bool</span> cut[N]; <span class="comment">// 判断是否为割点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    ver[++cnt]=v,nxt[cnt]=h[u],h[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[x];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">            Tarjan(y); <span class="comment">// 递归搜边</span></span><br><span class="line">            low[x]=min(low[x],low[y]); <span class="comment">// 更新low[x]</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;=dfn[x])&#123;</span><br><span class="line">                flag++;</span><br><span class="line">                <span class="keyword">if</span>(x!=rt || flag&gt;<span class="number">1</span>) cut[x]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x]=min(low[x],dfn[y]); <span class="comment">// (x,y)不是搜索树上的边</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        x=read(),y=read();</span><br><span class="line">        <span class="keyword">if</span>(x==y) <span class="keyword">continue</span>;</span><br><span class="line">        add(x,y),add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) rt=i,Tarjan(i);</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(cut[i]) sum++;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cut[i]) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="无向图Tarjan经典例题"><a href="#无向图Tarjan经典例题" class="headerlink" title="无向图Tarjan经典例题"></a>无向图Tarjan经典例题</h2><h3 id="BZOJ-1123-BLO"><a href="#BZOJ-1123-BLO" class="headerlink" title="[BZOJ-1123]BLO"></a><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1123" target="_blank" rel="noopener">[BZOJ-1123]BLO</a></h3><p><a href="https://www.luogu.org/problem/P3469" target="_blank" rel="noopener">你谷链接</a></p>
<blockquote>
<p>题面：</p>
</blockquote>
<p>给定一张无向图，求每个点被封锁之后有多少个<strong>有序</strong>点对(x,y)(x!=y,1&lt;=x,y&lt;=n)满足x无法到达y</p>
<p>你需要输出$n$个整数，其中第$i$个整数表示把与节点$i$关联的所有边去掉之后(不去掉节点$i$本身)，无向图中有多少个有序点对$(x,y)$，满足$x$和$y$不连通</p>
<p>$N \leq 10^5, M \leq 10^5$</p>
<blockquote>
<p>解法：</p>
</blockquote>
<p>根据割点的定义</p>
<p>若$i$不是割点，那么删边操作之后，只有$i$与其他$n-1$个节点不同，对答案贡献为$2*(n-1)$</p>
<p>若$i$是割点，那么删边操作之后，图分成若干连通块。求出这些连通块的大小，两两相乘再相加。设在搜索树上，节点$i$的子节点集合中，有$t$个点满足$dfn[i]&lt;=low[s_k]$。<br>于是删除$i$关联的所有边之后，无向图至多分成$t+2$个连通块，每个连通块节点构成情况为：</p>
<ol>
<li>节点$i$自身单独构成一个连通块</li>
<li>有$t$个连通块，分别由<strong>搜索树上</strong>以$s_k$($1 \leq k \leq t$)为根的子树中的节点构成</li>
<li>可能还有一个连通块，由除了上述节点之外的所有点构成</li>
</ol>
<p>因此可以在$Tarjan$算法执行DFS的过程中，求出搜索树每棵”子树”的大小$size[x]$。<br>那么删除割点i之后，不连通的有序对数量为： </p>
<p>$\Sigma _{i=1}^t$ $size[s_i]*(n-size[s_i])$ $+$ $(n-1)+(n-1- \Sigma _{k=1}^t size[s_k])$ * $(1+ \Sigma _{k=1}^t size[s_k])$</p>
<blockquote>
<p>代码实现：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt,num;</span><br><span class="line"><span class="keyword">int</span> h[N],ver[M&lt;&lt;<span class="number">1</span>],nxt[M&lt;&lt;<span class="number">1</span>]; <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],siz[N],ans[N];</span><br><span class="line"><span class="keyword">bool</span> cut[N]; <span class="comment">// 割点判定</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    ver[++cnt]=v,nxt[cnt]=h[u],h[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    siz[x]=<span class="number">1</span>;</span><br><span class="line">    dfn[x]=low[x]=++num;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[x];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            tarjan(y);</span><br><span class="line">            siz[x]+=siz[y];</span><br><span class="line">            low[x]=min(low[x],low[y]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;=dfn[x])&#123;</span><br><span class="line">                flag++;</span><br><span class="line">                ans[x]+=siz[y]*(n-siz[y]);</span><br><span class="line">                sum+=siz[y];</span><br><span class="line">                <span class="keyword">if</span>(x!=<span class="number">1</span> || flag&gt;<span class="number">1</span>) cut[x]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x]=min(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cut[x]) ans[x]+=(n-sum<span class="number">-1</span>)*(sum+<span class="number">1</span>)+(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> ans[x]=<span class="number">2</span>*(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        x=read(),y=read();</span><br><span class="line">        <span class="keyword">if</span>(x==y) <span class="keyword">continue</span>;</span><br><span class="line">        add(x,y),add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cerr&lt;&lt;"fuck"&lt;&lt;endl;</span></span><br><span class="line">    tarjan(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Part2-有向图的缩点"><a href="#Part2-有向图的缩点" class="headerlink" title="$Part2$ 有向图的缩点"></a>$Part2$ 有向图的缩点</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>给定有向图$G=(V,E)$，若存在$r \in V$，满足从$r$出发可以到达所有的节点，那么$G$是一张<strong>流图</strong>，钦定$r$为源点</p>
<p>在一张流图上从$r$开始DFS，也可以生成流图的搜索树，对应的有<strong>时间戳</strong>$dfn[x]$</p>
<p>流图中的每条有向边$(x,y)$必然是以下四种之一：</p>
<ol>
<li>树枝边，即搜索树中的边，即$x$是$y$的父节点</li>
<li>前向边，即搜索树中$x$是$y$的祖先节点</li>
<li>后向边</li>
<li>横叉边，一定满足$dfn[y]&lt;dfn[x]$</li>
</ol>
<h2 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h2><p>给定一个有向图，若对于图中任意两个节点$x,y$都能相互到达，那么称该图为<strong>强连通图</strong>。</p>
<p>有向图的极大强连通子图成为强连通分量<strong>SCC</strong></p>
<p>如果$x$，$y$可以相互到达，那么肯定在一个环中</p>
<ul>
<li>通过一条后向边，那么就满足一个环的成立</li>
<li>如果$x$，$y$之间有一条横叉边，那么就要视情况而定，如果从$y$出发可以找到一条返回$x$的祖先的路径，那么这条边也是有用的</li>
</ul>
<p>为了找后向边和横叉边构成的环，Tarjan算法在DFS的同时维护了一个栈。当访问到节点$x$，需要记录一下两类节点：</p>
<ol>
<li>搜索树上$x$的祖先节点，记为集合$anc(x)$，设$y \in anc(x)$。若存在后向边(x,y)，则$(x,y)$和$y$到$x$的路径一起形成环。</li>
<li>已经访问过，并且存在一条路径到达$anc(x)$的节点。</li>
</ol>
<p>设$z$是这样的一个点，从$z$出发存在一条路径到达$y \in anc(x)$。若存在横叉边$(x,z)$，则上述的边形成一个环</p>
<h3 id="追溯值"><a href="#追溯值" class="headerlink" title="追溯值"></a>追溯值</h3><p>设$subtree(x)$表示流图的搜索树中以$x$为根的子树。$x$的追溯值$low[x]$定义为满足以下条件节点的最小时间戳：</p>
<ol>
<li>该点在栈中</li>
<li>存在一条从$subtree(x)$出发的有向边|后向边，以该点为终点</li>
</ol>
<p>根据定义，Tarjan算法按照一下步骤计算追溯值：</p>
<ol>
<li>当节点第一次被访问时，把$x$入栈，初始化$low[x]=dfn[x]$</li>
<li>扫描从$x$出发的每条边$(x,y)$。<ol>
<li>若$y$没被访问过，说明(x,y)是树枝边，递归访问$y$，从$y$回溯之后，令$low[x]=min(low[x],low[y])$。</li>
<li>若$y$被访问过并且$y$在栈中，则令$low[x]=min(low[x],dfn[y])$</li>
</ol>
</li>
<li>从$x$回溯之前，判断是否有$low[x]=dfn[x]$。若成立，则不断从栈中弹出节点知道$x$出栈</li>
</ol>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> ver[M],nxt[M],h[N];</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[N],ins[N],c[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;SCC[N];</span><br><span class="line"><span class="keyword">int</span> n,m,cnt,num,top,tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    ver[++cnt]=v,nxt[cnt]=h[u],h[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++num;</span><br><span class="line">    <span class="built_in">stack</span>[++top]=x,ins[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            tarjan(y);</span><br><span class="line">            low[x]=min(low[x],low[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ins[y])</span><br><span class="line">            low[x]=min(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[x]==low[x])&#123;</span><br><span class="line">        tot++,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            y=<span class="built_in">stack</span>[top--],ins[y]=<span class="number">0</span>;</span><br><span class="line">            c[y]=tot,SCC[tot].push_back(y);</span><br><span class="line">        &#125;<span class="keyword">while</span>(x!=y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        x=read(),y=read();</span><br><span class="line">        add(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) tarjan(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
        <tag>割点</tag>
      </tags>
  </entry>
  <entry>
    <title>Manacher</title>
    <url>/2020/10/24/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/manacher/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个长度为$n$的字符串，要求找出所有对$(i,j)$使得子串$s[i…j]$为一个回文串</p>
<p>最坏情况下有$O(n^2)$个回文串</p>
<h2 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h2><p>引入一种表达回文串的方式：</p>
<p>对于每个位置$i=0…n-1$，有$d_1[i]$和$d_2[i]$分别表示以$i$为中心的长度为奇数和长度为偶数的回文串个数</p>
<p>例如，对于字符串$a b a b a c$，有</p>
<p>$$d_1[3] = 3$$</p>
<p>这里单个字符本身也算作一个回文串</p>
<p>对于字符串$cbaabd$，有</p>
<p>$$d_2[3] = 2$$</p>
<p>显然，如果以某个位置$i$为中心，若有长度为$l$的回文串，那么就存在长度为$l-2$、$l-4$的回文串</p>
<p>则$d_1[]$和$d_2[]$两个数组就可以描述字符串中的所有回文串信息</p>
<h2 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h2><p>可以在$O(n^2)$的时间内计算出答案</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; d1(n), d2(n);</span><br><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; n; <span class="built_in">i</span>++) &#123;</span><br><span class="line">  d1[<span class="built_in">i</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span> &lt;= <span class="built_in">i</span> - d1[<span class="built_in">i</span>] &amp;&amp; <span class="built_in">i</span> + d1[<span class="built_in">i</span>] &lt; n &amp;&amp; s[<span class="built_in">i</span> - d1[<span class="built_in">i</span>]] == s[<span class="built_in">i</span> + d1[<span class="built_in">i</span>]]) &#123;</span><br><span class="line">    d1[<span class="built_in">i</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  d2[<span class="built_in">i</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span> &lt;= <span class="built_in">i</span> - d2[<span class="built_in">i</span>] - <span class="number">1</span> &amp;&amp; <span class="built_in">i</span> + d2[<span class="built_in">i</span>] &lt; n &amp;&amp;</span><br><span class="line">         s[<span class="built_in">i</span> - d2[<span class="built_in">i</span>] - <span class="number">1</span>] == s[<span class="built_in">i</span> + d2[<span class="built_in">i</span>]]) &#123;</span><br><span class="line">    d2[<span class="built_in">i</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>01分数规划</title>
    <url>/2020/10/24/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>01分数规划是二分答案中的一类常见问题</p>
<a id="more"></a>
<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>给你n对元素vi,wi,要求从中挑选出k对，使得，v的和除以w的和最大</p>
<h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p>假设我们已经求得了这个最大的值 x = sigma v [ i ] / sigma w [ i ] ;</p>
<p>则有</p>
<p>sigma(v [ i ] ) / sigma(w [ i ] ) &gt;= x -&gt; sigma(v [ i ] - x * w [ i ] ) &gt;= 0</p>
<p>在数据确定的情况下，这个式子具有单调性，所以我们可以考虑二分求解这个x值</p>
<h2 id="经典例题："><a href="#经典例题：" class="headerlink" title="经典例题："></a>经典例题：</h2><h3 id="POJ-3111-K-Best"><a href="#POJ-3111-K-Best" class="headerlink" title="POJ 3111 K Best"></a><a href="http://poj.org/problem?id=3111" target="_blank" rel="noopener">POJ 3111 K Best</a></h3><p>模板题..</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v[maxn], w[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> val;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; a.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        f = (ch == <span class="string">'-'</span>) ? <span class="number">-1</span> : <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        x = x * <span class="number">10</span> + (ch - <span class="string">'0'</span>), ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        f[i].val = v[i] - x * w[i], f[i].id = i + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::sort(f, f + n);</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += f[i].val;</span><br><span class="line">        ans[i] = f[i].id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), k = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        v[i] = read(), w[i] = read();</span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">0</span>, r = INF;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">1e-8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid))</span><br><span class="line">            l = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f[i].id;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k - <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>学习笔记</tag>
        <tag>01分数规划</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>「CF 739B」Alyona and a tree</title>
    <url>/2020/10/24/OI/Codeforces/CF739B/</url>
    <content><![CDATA[<p>一道树形结构经典题，感觉蒟蒻这辈子都没法在比赛的时候切Div.1的题目ler</p>
<a id="more"></a>

<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一棵树，每个节点和边都有一个值，任取一个节点u，在它的子树中任取一个v，若dis(u,v) &lt; val[v]，那么我们说u控制了v，要求输出每个节点控制的节点数目</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>正常的DFS肯定会爆炸，我们考虑O(n)DFS统计信息，然后树上倍增+树上差分统计每个节点控制的节点数，因为距离值具有单调性可以倍增跳节点</p>
<h2 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"><span class="keyword">int</span> n,cnt;</span><br><span class="line"><span class="keyword">int</span> a[N],d[N],f[N][<span class="number">25</span>],ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> to,nxt;&#125; e[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">1</span>,x=<span class="number">0</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span>  x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;e[++cnt].to=v,e[cnt].nxt=h[u],h[u]=cnt;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    d[u]+=d[fa],f[u][<span class="number">0</span>]=fa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i;i=e[i].nxt) dfs(e[i].to,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;<span class="keyword">return</span> d[u]-d[v];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i;i=e[i].nxt)&#123;</span><br><span class="line">        solve(e[i].to,k);</span><br><span class="line">        ans[u]+=ans[e[i].to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        u=read(),v=read();</span><br><span class="line">        d[i]+=v;</span><br><span class="line">        add(u,i);</span><br><span class="line">    &#125;</span><br><span class="line">    d[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i][j]=f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">20</span>;j&gt;=<span class="number">0</span>;j--)&#123; <span class="comment">// 倍增跳节点</span></span><br><span class="line">            <span class="keyword">if</span>(dis(i,f[pos][j])&lt;=a[i]) pos=f[pos][j];</span><br><span class="line">        &#125;</span><br><span class="line">        ans[f[pos][<span class="number">0</span>]]--,ans[f[i][<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    solve(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>「NOIP2016」蚯蚓 队列+二叉堆</title>
    <url>/2019/11/11/OI/%E9%A2%98%E8%A7%A3/NOIP2016%E8%9A%AF%E8%9A%93/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P2827" target="_blank" rel="noopener">题目传送门</a></p>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。<br>蛐蛐国里现在共有 $n$ 只蚯蚓（$n$ 为正整数）。每只蚯蚓拥有长度，我们设第 $i$ 只蚯蚓的长度为 $a_i$<br>  ($1 \leq i \leq n$)，并保证所有的长度都是非负整数（即：可能存在长度为 $0$ 的蚯蚓）。</p>
<p>每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数 $p$（是满足 $0&lt;p&lt;1$ 的有理数）决定，设这只蚯蚓长度为 $x$，神刀手会将其切成两只长度分别为 $\lfloor px \rfloor$ 和 $x - \lfloor px \rfloor$ 的蚯蚓。如果这两个数的其中一个等于 $0$，则这个长度为 $0$ 的蚯蚓也会被保留。除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加 $q$（是一个非负整常数）。</p>
<p>蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 $m$ 秒才能到来……（$m$ 为非负整数）</p>
<p>蛐蛐国王希望知道这 $m$ 秒内的战况。具体来说，他希望知道：</p>
<p>$m$ 秒内，每一秒被切断的蚯蚓被切断前的长度（有 $m$ 个数）；<br>$m$ 秒后，所有蚯蚓的长度（有 $n + m$ 个数）。<br>蛐蛐国王当然知道怎么做啦！但是他想考考你……</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含六个整数 $n,m,q,u,v,t$，其中$n,m,q$见题目描述，需要自己计算$p=u/v$，$t$为输出参数</p>
<p>第二行包含$n$个非负整数，为$a_1,a_2,\dots,a_n$，即初始时$n$只蚯蚓的长度</p>
<p>保证$1\leq n\leq 10^5$,$0\leq m\leq 7*10^6$,$0&lt;u&lt;v\leq 10^9$,$0\leq q\leq 200$,$1\leq t\leq10^7$,$0\leq a_i \leq10^8$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>第一行输出$\lfloor{\frac m t}\rfloor$个整数，按时间顺序输出，依次输出第$t$秒，第$2t$秒，第$3t$秒，$\dots$被斩断蚯蚓的长度</p>
<p>第二行输出$\lfloor \frac {n+m} t\rfloor$个整数，输出$m$秒后蚯蚓的长度；需要从大到小的排序，依次输出排名第$t$，$2t$，$\dots$的长度</p>
<p>同一行中相邻的两个数之间，恰好用一个空格隔开。即使某一行没有任何数需要输出，你也应输出一个空行。</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>如果$q=0$，即蚯蚓不会变长，那么本题相当于维护一个集合支持最大值查询 | 删除最大值 | 插入新的值，这个使用二叉堆或者平衡树$STL \ \ set$就可以做到，时间复杂度为$O(m\ logn)$</p>
<p>当$q&gt;0$时，除了最大值拆成的两个数之外，集合中的其他数都会增加$q$。设最大值为x，我们不妨认为产生了两个大小为$\lfloor{px}\rfloor-q$和$n-\lfloor{px}\rfloor-q$的新数，再把整个集合加上$q$</p>
<p>可以维护一个偏移量$delta$，集合中的数加上$delta$就是真实数值</p>
<p>但是，仅仅按照上述的方法进行$m$轮模拟肯定会T飞</p>
<p>设$x_1,x_2$为非负整数，当$x_1\geq x_2$时，有$\lfloor{px_1}\rfloor+q\geq\lfloor{px_2}\rfloor+pq$</p>
<p>可理解为$\lfloor{px_1+q}\rfloor\geq\lfloor{p(x_2+q)}\rfloor$</p>
<p>又因为有<br>$$x_1-x_2\geq p(x_1-x_2)$$</p>
<p>所以有<br>$$x_1-px_1\geq x_2-px_2\geq x_2-p(x_2+q)$$</p>
<p>进一步有</p>
<p>$$x_1-\lfloor{px_1}\rfloor+q=\lfloor{x_1-px_1}\rfloor+q\geq \lfloor{x_2-p(x_2+q)}\rfloor+q=x_2+q-\lfloor{p(x_2+q)}\rfloor$$</p>
<p>意义是：若$x_1$在$x_2$前被取出集合，则在一秒后，$x_1$分成两个数$\lfloor{px_1}\rfloor+q$和$x-1-\lfloor{px_1}\rfloor+q$分别不小于$x_2$分成的两个数$\lfloor{p(x_2+q)}\rfloor$和$x_2+q-\lfloor{p(x_2+q)}\rfloor$</p>
<p>那么，不仅从集合中取出的数是单调递减的，新产生的两类数值也是随时间单调递减的</p>
<p>我们建立三个队列$A,B,C$</p>
<p>A维护初始的n个数，从大到小排序，队列$B$保存每秒新产生的$\lfloor{px}\rfloor$的那一段数值。队列$C$保存1剩下的一类数值，单调性保证数据的顺序同步，此时集合中最大的数就是队列$A,B,C$的三个队首之一，配合集合的偏移量$delta$，整个算法的时间复杂度为$O(m+nlogn)$</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* PP2728 蚯蚓 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt;q1;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q2,q3;</span><br><span class="line"><span class="keyword">int</span> n,m,q,u,v,t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxLen</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1=<span class="number">-1</span>,x2=<span class="number">-1</span>,x3=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!q1.empty()) x1=q1.top()+t*q;</span><br><span class="line">    <span class="keyword">if</span>(!q2.empty()) x2=q2.front()+t*q;</span><br><span class="line">    <span class="keyword">if</span>(!q3.empty()) x3=q3.front()+t*q;</span><br><span class="line">    <span class="keyword">if</span>(x1&gt;=x2 &amp;&amp; x1&gt;=x3)&#123;q1.pop();<span class="keyword">return</span> x1;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x2&gt;=x1&amp;&amp;x2&gt;=x3)&#123;q2.pop();<span class="keyword">return</span> x2;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;q3.pop();<span class="keyword">return</span> x3;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("earthworm.in","r",stdin);</span></span><br><span class="line">    <span class="comment">// freopen("earthworm.out","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>,&amp;n,&amp;m,&amp;q,&amp;u,&amp;v,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="keyword">int</span> x;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x),q1.push(x);&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> t1,t2,len=MaxLen(i<span class="number">-1</span>);</span><br><span class="line">        t1=len*u/v;t2=len-t1;</span><br><span class="line">        q2.push(t1-i*q);q3.push(t2-i*q);</span><br><span class="line">        <span class="keyword">if</span>(i%t==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;len&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m+n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> len=MaxLen(m);</span><br><span class="line">        <span class="keyword">if</span>(i%t==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;len&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二叉堆</tag>
        <tag>思维</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P3373」线段树1</title>
    <url>/2019/10/09/OI/%E6%A8%A1%E6%9D%BF/%5B%E6%A8%A1%E6%9D%BF%5D%E7%BA%BF%E6%AE%B5%E6%A0%911/</url>
    <content><![CDATA[<p>线段树模板题，详情参阅博文 【学习笔记】初级线段树，这里不再赘述，直接给出代码</p>
<a id="more"></a>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">/* <span class="symbol">P3372</span> [模板]线段树<span class="number">1</span> */</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define <span class="built_in">int</span> long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const <span class="built_in">int</span> <span class="built_in">N</span>=<span class="number">1</span>e5+<span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> <span class="built_in">n</span>,m,a[<span class="built_in">N</span>];</span><br><span class="line">struct Node&#123;</span><br><span class="line">    <span class="built_in">int</span> l,r,<span class="built_in">sum</span>,add;</span><br><span class="line">&#125;<span class="built_in">t</span>[<span class="built_in">N</span>&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">void build(<span class="built_in">int</span> p,<span class="built_in">int</span> l,<span class="built_in">int</span> r)&#123;</span><br><span class="line">    <span class="built_in">t</span>[p].l=l,<span class="built_in">t</span>[p].r=r;</span><br><span class="line">    <span class="built_in">if</span>(l==r)&#123;</span><br><span class="line">        <span class="built_in">t</span>[p].<span class="built_in">sum</span>=a[l];return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">mid</span>=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(p&lt;&lt;<span class="number">1</span>,l,<span class="built_in">mid</span>);</span><br><span class="line">    build(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,<span class="built_in">mid</span>+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">t</span>[p].<span class="built_in">sum</span>=<span class="built_in">t</span>[p&lt;&lt;<span class="number">1</span>].<span class="built_in">sum</span>+<span class="built_in">t</span>[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].<span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline <span class="built_in">int</span> read()&#123;</span><br><span class="line">    <span class="built_in">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="built_in">char</span> ch=getchar();</span><br><span class="line">    while(!isdigit(ch)) f=(ch=='-')?-<span class="symbol">1:1</span>,ch=getchar();</span><br><span class="line">    while(isdigit(ch)) x=x*<span class="number">10</span>+(ch-'<span class="number">0</span>'),ch=getchar();</span><br><span class="line">    return x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void f(<span class="built_in">int</span> p,<span class="built_in">int</span> k)&#123;</span><br><span class="line">    <span class="built_in">t</span>[p].add+=k; // 为什么是+=而不是=可以思考一下</span><br><span class="line">    <span class="built_in">t</span>[p].<span class="built_in">sum</span>+=k*(<span class="built_in">t</span>[p].r-<span class="built_in">t</span>[p].l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void push_down(<span class="built_in">int</span> p)&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">mid</span>=(<span class="built_in">t</span>[p].l+<span class="built_in">t</span>[p].r)&gt;&gt;<span class="number">1</span>; // 标记下传</span><br><span class="line">    f(p&lt;&lt;<span class="number">1</span>,<span class="built_in">t</span>[p].add);</span><br><span class="line">    f(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,<span class="built_in">t</span>[p].add);</span><br><span class="line">    <span class="built_in">t</span>[p].add=<span class="number">0</span>; // 清空本身标记</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void change(<span class="built_in">int</span> p,<span class="built_in">int</span> x,<span class="built_in">int</span> y,<span class="built_in">int</span> k)&#123;</span><br><span class="line">    <span class="built_in">if</span>(x&lt;=<span class="built_in">t</span>[p].l&amp;&amp;<span class="built_in">t</span>[p].r&lt;=y) &#123;f(p,k);return ;&#125;</span><br><span class="line">    push_down(p);</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">mid</span>=(<span class="built_in">t</span>[p].l+<span class="built_in">t</span>[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">if</span>(x&lt;=<span class="built_in">mid</span>) change(p&lt;&lt;<span class="number">1</span>,x,y,k);</span><br><span class="line">    <span class="built_in">if</span>(y&gt;<span class="built_in">mid</span>) change(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y,k);</span><br><span class="line">    <span class="built_in">t</span>[p].<span class="built_in">sum</span>=<span class="built_in">t</span>[p&lt;&lt;<span class="number">1</span>].<span class="built_in">sum</span>+<span class="built_in">t</span>[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].<span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> query(<span class="built_in">int</span> p,<span class="built_in">int</span> x,<span class="built_in">int</span> y)&#123;</span><br><span class="line">    <span class="built_in">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">if</span>(x&lt;=<span class="built_in">t</span>[p].l&amp;&amp;<span class="built_in">t</span>[p].r&lt;=y)&#123;</span><br><span class="line">        return <span class="built_in">t</span>[p].<span class="built_in">sum</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(p); // 因为要查询，必须向下传递，如果左右儿子也要查询，那么自然会继续下传，否则就不用下传，这就是懒标记的省时之处</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">mid</span>=(<span class="built_in">t</span>[p].l+<span class="built_in">t</span>[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">if</span>(x&lt;=<span class="built_in">mid</span>) res+=query(p&lt;&lt;<span class="number">1</span>,x,y);</span><br><span class="line">    <span class="built_in">if</span>(y&gt;<span class="built_in">mid</span>) res+=query(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    <span class="built_in">n</span>=read(),m=read();</span><br><span class="line">    for(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">n</span>;i++) a[i]=read();</span><br><span class="line">    build(<span class="number">1</span>,<span class="number">1</span>,<span class="built_in">n</span>);</span><br><span class="line">    <span class="built_in">int</span> op,x,y,k;</span><br><span class="line">    for(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        op=read(),x=read(),y=read();</span><br><span class="line">        <span class="built_in">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            k=read();</span><br><span class="line">            change(<span class="number">1</span>,x,y,k);</span><br><span class="line">        &#125;</span><br><span class="line">        else cout&lt;&lt;query(<span class="number">1</span>,x,y)&lt;&lt;'\n';</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P2043」质因子分解</title>
    <url>/2019/10/08/OI/%E9%A2%98%E8%A7%A3/LGP2043%E8%B4%A8%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3/</url>
    <content><![CDATA[<p>对N!进行质因子分解</p>
<p>一道红的发黄的题目，蒟蒻一个”=”调了一中午</p>
<a id="more"></a>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>可以推导出对于每个数n，每个质数出现的次数为:</p>
<p>n/p^1+n/p^2+…+n/p^k</p>
<p>欧拉筛出所有质数，统计即可</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> m=<span class="number">0</span>,p[N],v[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            p[++m]=i,v[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j]&gt;v[i]||p[j]&gt;n/i) <span class="keyword">break</span>;</span><br><span class="line">            v[i*p[j]]=p[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    Prime(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> now=p[i];</span><br><span class="line">        <span class="keyword">while</span>(now&lt;=n)&#123;</span><br><span class="line">            ans+=n/now;</span><br><span class="line">            now*=p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p[i]&lt;&lt;<span class="string">' '</span>&lt;&lt;ans&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>筛法</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P1120」小木棍</title>
    <url>/2019/10/06/OI/%E9%A2%98%E8%A7%A3/LGP1120%E5%B0%8F%E6%9C%A8%E6%A3%8D/</url>
    <content><![CDATA[<p>给定n个长度不等的小木棍，由一些数量位置长度相等的木棍砍得，问原木棍长度最小可能值，需要手动忽略长度a[i]&gt;50的数据</p>
<a id="more"></a>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><blockquote>
<p><a href="https://www.luogu.org/problem/P1120" target="_blank" rel="noopener">[洛谷 P1120] 小木棍</a></p>
</blockquote>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>一道经典的深搜剪枝习题</p>
<p>以最小长度为目标深搜，搜索满足条件的最小解</p>
<p>剪枝：</p>
<ul>
<li>木棍的最小长度肯定大于小木棍的最大的一个长度，肯定小于所有小木棍长度的总和</li>
<li>原始长度只需要枚举到sum/2，再大就只有一种情况就是sum</li>
<li>可以对小木棍长度从大到小排序方便优化选取的过程(感性理解)</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* P1120 小木棍 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[<span class="number">70</span>], nxt[<span class="number">70</span>], cnt, sum, len;</span><br><span class="line"><span class="keyword">bool</span> used[<span class="number">70</span>], ok;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> last, <span class="keyword">int</span> rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (!rest)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == m)</span><br><span class="line">        &#123;</span><br><span class="line">            ok = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">            <span class="keyword">if</span> (!used[i])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        used[i] = <span class="number">1</span>;</span><br><span class="line">        dfs(k + <span class="number">1</span>, i, len - a[i]);</span><br><span class="line">        used[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ok)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = last + <span class="number">1</span>, r = cnt, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt;= rest)</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = l; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!used[i])</span><br><span class="line">        &#123;</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            dfs(k, i, rest - a[i]);</span><br><span class="line">            used[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ok)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (rest == a[i] || rest == len)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            i = nxt[i];</span><br><span class="line">            <span class="keyword">if</span> (i == cnt)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        d = read();</span><br><span class="line">        <span class="keyword">if</span> (d &gt; <span class="number">50</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        a[++cnt] = d;</span><br><span class="line">        sum += d;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + cnt + <span class="number">1</span>, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    nxt[cnt] = cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == a[i + <span class="number">1</span>])</span><br><span class="line">            nxt[i] = nxt[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nxt[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (len = a[<span class="number">1</span>]; len &lt;= sum / <span class="number">2</span>; len++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum % len != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        m = sum / len;</span><br><span class="line">        ok = <span class="number">0</span>;</span><br><span class="line">        used[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">1</span>, len - a[<span class="number">1</span>]);</span><br><span class="line">        used[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ok)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;len;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 580(Div.2)</title>
    <url>/2019/10/04/OI/Codeforces/CF1206Div.2/</url>
    <content><![CDATA[<h1 id="Codeforces-Round-580-Div-2"><a href="#Codeforces-Round-580-Div-2" class="headerlink" title="Codeforces Round #580 Div.2"></a>Codeforces Round #580 Div.2</h1><h2 id="赛程回顾"><a href="#赛程回顾" class="headerlink" title="赛程回顾"></a>赛程回顾</h2><p>蒟蒻来订正不知道多早以前打的比赛了。。。</p>
<p>不知道为什么到现在我无论Div.2或Div.3还是只能切两题，XY巨佬把把AK，蒟蒻只有眼馋的分</p>
<p>蒟蒻10min的时候才切了A，53min的时候在康了XY巨佬的代码下才勉强A掉</p>
<a id="more"></a>
<p>剩下一个C有了一个思路但却是连DFS都不会写，事实如此</p>
<p>于是之后就是颓废时间。。。</p>
<blockquote>
<h2 id="比赛中的失误："><a href="#比赛中的失误：" class="headerlink" title="比赛中的失误："></a>比赛中的失误：</h2><ul>
<li>英文读题能力还是要加强</li>
<li>代码能力低，实现速度慢，浪费时间多</li>
<li>缺乏针对题目的造样例调试能力</li>
<li>没有部分分导致对着一道题猛写一次未交一分未得的情况，OI赛制中也如此，从而失去宝贵的部分分</li>
</ul>
</blockquote>
<h2 id="A-Choose-Two-Numbers-签到题"><a href="#A-Choose-Two-Numbers-签到题" class="headerlink" title="A.Choose Two Numbers [签到题]"></a>A.Choose Two Numbers [签到题]</h2><h3 id="题意简述："><a href="#题意简述：" class="headerlink" title="题意简述："></a>题意简述：</h3><p>给定两个长度为n,m的序列，求出两序列中元素之和不在两序列中的两个元素并输出</p>
<h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><p>取两个序列中的元素的两个最大值，其和定不在任意一个序列中,O(n+m)扫描最值输出即可</p>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> x, y, Max1, Max2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        f = (ch == <span class="string">'-'</span>) ? <span class="number">-1</span> : <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        x = x * <span class="number">10</span> + (ch - <span class="string">'0'</span>), ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        x = read(), Max1 = <span class="built_in">std</span>::max(Max1, x);</span><br><span class="line">    m = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        x = read(), Max2 = <span class="built_in">std</span>::max(Max2, x);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Max1 &lt;&lt; <span class="string">' '</span> &lt;&lt; Max2 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Make-Product-Equal-One-贪心"><a href="#B-Make-Product-Equal-One-贪心" class="headerlink" title="B.Make Product Equal One [贪心]"></a>B.Make Product Equal One [贪心]</h2><h3 id="题意简述：-1"><a href="#题意简述：-1" class="headerlink" title="题意简述："></a>题意简述：</h3><p>给定一个长为n的序列，每次可以花费x的代价将任意一个元素增加或减少x，经过若干次操作，使得Π a[i]=1,(1&lt;=i&lt;=n)</p>
<h3 id="思路浅析"><a href="#思路浅析" class="headerlink" title="思路浅析:"></a>思路浅析:</h3><p>贪心的思想，所有<strong>小于0的数字向-1靠</strong>,ans+-1-a[i]，<strong>大于0的数字向1靠</strong>，有0的话答案就+1，最终如果没有0并且结果为-1，那么说明需要把一个-1改为1，ans+=2，输出即可</p>
<h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans, x, cnt, tot;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        f = (ch == <span class="string">'-'</span>) ? <span class="number">-1</span> : <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        x = x * <span class="number">10</span> + (ch - <span class="string">'0'</span>), ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x = read();</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            ans += -x - <span class="number">1</span>, tot++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">            cnt++, ans++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans += x - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += (!cnt &amp;&amp; tot % <span class="number">2</span>) ? <span class="number">2</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Almost-Equal"><a href="#C-Almost-Equal" class="headerlink" title="C.Almost Equal"></a>C.Almost Equal</h2><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给定一个数字n，将1-n个数字摆成一个环。</p>
<h2 id="待续ing"><a href="#待续ing" class="headerlink" title="待续ing"></a>待续ing</h2>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP初赛复习知识点整理</title>
    <url>/2019/10/04/OI/%E8%AE%AD%E7%BB%83/CSP%E5%88%9D%E8%B5%9B%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="List："><a href="#List：" class="headerlink" title="List："></a>List：</h1><ul>
<li><p>递推</p>
<ul>
<li><p>卡特兰数（节点数为n的二叉树的形态个数）</p>
</li>
<li><p>算法时间复杂度递推方程</p>
</li>
</ul>
</li>
<li><p>多项式时间与NP/P问题</p>
</li>
<li><p>竞赛历史</p>
<ul>
<li><a href="https://oi-wiki.org/intro/oi/" target="_blank" rel="noopener">NOI/IOI/APIO/CSTC相关</a></li>
</ul>
</li>
<li><p>哈夫曼树</p>
</li>
<li><p>逆波兰表达式、前缀表达式、中缀表达式</p>
</li>
<li><p>IP地址</p>
</li>
<li><p>进制</p>
</li>
<li><p>邻接矩阵/邻接表</p>
</li>
<li><p><strong>二叉树</strong></p>
</li>
<li><p>计算机结构基础知识</p>
</li>
<li><p>逻辑运算、非与或</p>
</li>
<li><p>手动递归(大题)</p>
</li>
<li><p>数学期望、概率(建议蒙题)</p>
</li>
<li><p>图论：</p>
<ul>
<li>完全图 [概念]</li>
<li>邻接表 [全部]</li>
<li>DFS序</li>
<li>树边、横叉边、返祖边</li>
<li>各类最短路算法</li>
</ul>
</li>
<li><p>数论基础：</p>
<ul>
<li>同余<ul>
<li>费马小定理</li>
<li>欧拉函数</li>
</ul>
</li>
</ul>
</li>
<li><p>信息存储：(高中技术必修一)</p>
<ul>
<li>空间转换</li>
</ul>
</li>
<li><p>算法时间复杂度递推计算</p>
</li>
<li><p>一些知识：</p>
<ul>
<li>纯函数式语言：haskell</li>
<li><a href="https://baike.baidu.com/item/5G/29780?fr=aladdin" target="_blank" rel="noopener">5G</a></li>
</ul>
</li>
<li><p>基础数据结构</p>
<ul>
<li>栈、单调栈、出入栈顺序</li>
<li>队列、单调队列、循环队列、双端队列(deque)</li>
<li>链表的各种操作(增删查补替排)、双端链表<ul>
<li><strong>交换时</strong>的顺序问题</li>
</ul>
</li>
</ul>
</li>
<li><p>图的各种概念</p>
<ul>
<li>完全图</li>
</ul>
</li>
<li><p>二分图基础</p>
<ul>
<li>最大匹配</li>
<li>最小点覆盖</li>
<li>最小边覆盖</li>
<li>最大独立集</li>
</ul>
</li>
<li><p>机器字长、指令字长、存储字长</p>
</li>
<li><p>计算几何初步</p>
<ul>
<li>自然数幂求和(扰动法)</li>
</ul>
</li>
<li><p>字符串相关</p>
<ul>
<li>KMP算法</li>
<li>Trie树</li>
<li>Hash<ul>
<li>探测冲突</li>
<li>探测因子</li>
</ul>
</li>
</ul>
</li>
<li><p>二份|分治思想</p>
</li>
<li><p>容斥原理</p>
</li>
<li><p>排列组合</p>
</li>
</ul>
<h1 id="计算机发展历史-杂项："><a href="#计算机发展历史-杂项：" class="headerlink" title="计算机发展历史 / 杂项："></a>计算机发展历史 / 杂项：</h1><h2 id="冯诺伊曼计算机模型："><a href="#冯诺伊曼计算机模型：" class="headerlink" title="冯诺伊曼计算机模型："></a>冯诺伊曼计算机模型：</h2><ul>
<li><p>计算机主要由运算器、控制器、存储器、输入输出设备构成</p>
</li>
<li><p><strong>所有的指令都是由操作码和地址码构成</strong></p>
</li>
<li><p>程序和数据都以二进制的形式存放在存储器中</p>
</li>
<li><p>指令在其存储过程中按照执行的顺序存储</p>
</li>
<li><p>以运算器和控制器作为计算机结构的中心</p>
</li>
</ul>
<hr>
<h3 id="各类名词缩写："><a href="#各类名词缩写：" class="headerlink" title="各类名词缩写："></a>各类名词缩写：</h3><ul>
<li><p>计算机/现代集成制造系统 CIMS</p>
</li>
<li><p>计算机辅助制造 CAM</p>
</li>
<li><p>计算机辅助设计 CAD</p>
</li>
<li><p>计算机辅助教学 CAI</p>
</li>
<li><p>算术逻辑单元 ALU</p>
</li>
</ul>
<hr>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul>
<li><p>在关系数据库中，存放在数据库中的数据的逻辑结构以<strong>二维表</strong>为主</p>
</li>
<li><p>办公室自动化(OA)应用分类： 信息处理</p>
</li>
<li><p>衡量CPU速度的单位： MIPS</p>
</li>
<li><p>中国的第一枚计算机芯片： 龙芯</p>
</li>
</ul>
<h1 id="计算机系统："><a href="#计算机系统：" class="headerlink" title="计算机系统："></a>计算机系统：</h1><ul>
<li><p>外存： 硬盘 | SD卡 | 光盘 | 优盘 ……</p>
</li>
<li><p>内存： ROM | RAM | cache</p>
</li>
<li><p>主机：计算机除去输入输出设备以外的主要机体部分，有时候是CPU+内存(主存)，有时候包括主板(详见一本通初赛篇第二版模拟卷八)</p>
</li>
<li><p>硬盘上一个扇区的字节数为 <strong>512</strong></p>
</li>
</ul>
<h1 id="网络："><a href="#网络：" class="headerlink" title="网络："></a>网络：</h1><h2 id="计算机网络发展的三个阶段："><a href="#计算机网络发展的三个阶段：" class="headerlink" title="计算机网络发展的三个阶段："></a>计算机网络发展的三个阶段：</h2><ol>
<li>主机——终端</li>
<li>计算机阶段</li>
<li>Internet阶段(<strong>网络标准化</strong>)<h2 id="计算机网络定义："><a href="#计算机网络定义：" class="headerlink" title="计算机网络定义："></a>计算机网络定义：</h2></li>
</ol>
<ul>
<li><p>计算机网络是指利用通信线路和设备，把分布在不同地理位置上的多台计算机连接起来</p>
</li>
<li><p>计算机之间的通信依靠协议进行。协议是计算机收发数据的规则</p>
</li>
<li><p>计算机网络是一个在协议控制下的多机互联系统</p>
</li>
<li><p>我国1994年正式接入Internet</p>
<h2 id="按地理位置分类"><a href="#按地理位置分类" class="headerlink" title="按地理位置分类"></a>按地理位置分类</h2></li>
<li><p>LAN - 局域网</p>
</li>
<li><p>MAN - 城域网</p>
</li>
<li><p>WAN - 广域网</p>
<h2 id="按拓扑结构分类："><a href="#按拓扑结构分类：" class="headerlink" title="按拓扑结构分类："></a>按拓扑结构分类：</h2></li>
<li><p>星形</p>
</li>
<li><p>总线形</p>
</li>
<li><p>环形</p>
</li>
<li><p>树形</p>
</li>
<li><p>网状形</p>
</li>
</ul>
<p>Internet网连有许多不同拓扑结构的LAN、WAN、MAN，因此没有固定拓扑结构</p>
<h2 id="按采用的交换技术进行分类："><a href="#按采用的交换技术进行分类：" class="headerlink" title="按采用的交换技术进行分类："></a>按采用的交换技术进行分类：</h2><p>电路交换、报文交换、分组交换</p>
<h2 id="体系结构："><a href="#体系结构：" class="headerlink" title="体系结构："></a>体系结构：</h2><p>国际标准化组织提出了<strong>开放式系统互联(OSI)</strong>参考模型，开放性是指任何遵循OSI标准的系统，只要物理上连接起来，他们之间都可以相互通信</p>
<p>但是OSI参考模型并不是网络体系结构，OSI只是描述了每一层的功能，并没有确定每一层的协议，而<strong>网络体系结构是网络层次结构和相关协议的集合</strong></p>
<p>OSI7层模型(自顶向下)：<br>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p>
<p>TCP/IP 4层模型：<br><strong>应用层(对应OSI前三层)</strong>、传输层、国际互联层、<strong>网络接口层(对应OSI后两层)</strong>，中间两层一一对应</p>
<h2 id="IP地址："><a href="#IP地址：" class="headerlink" title="IP地址："></a>IP地址：</h2><blockquote>
<p>用于<strong>表示</strong>Internet<strong>网络</strong>上<strong>节点</strong>的<strong>32位</strong>地址，<strong>V6版本是128位的</strong>，分8组16位</p>
</blockquote>
<ul>
<li><p>每个地址由网络ID和主机ID组成，通常用句点分割的八位字节的十进制数表示：(192.168.7.27)</p>
</li>
<li><p>IP地址分为ABCDE五类，ABC为常用类</p>
</li>
<li><p>网络ID标识大规模的TCP/IP网际网络(由网络组成的网络)内的单个网段</p>
</li>
<li><p>主机ID标识每个网络内部的TCP/IP节点，每个设备的主机ID唯一地识别所在网络的单个系统</p>
</li>
<li><p>IP地址的主机号范围是0-255，但主机ID的所有域不能都为0或255：</p>
<ul>
<li>如果网络ID为10，那么不能分配10.0.0.0和10.255.255.255这两个IP地址</li>
<li>如果网络ID为192.114.31，那么就不能分配192.114.31.0和192.114.31.255</li>
</ul>
</li>
<li><p>ABC类网络地址</p>
<ul>
<li>A类:1.0.0.1 — 126.255.255.254</li>
<li>B类:128.1.0.1 — 191.255.255.254</li>
<li>C类:192.0.0.1 — 223.255.255.254</li>
</ul>
</li>
<li><p>仅供单位内部使用而不用付费的专网IP地址：</p>
<ul>
<li>A:10.0.0.0 – 10.255.255.255</li>
<li>B:172.16.0.0 – 172.31.255.255</li>
<li>C:192.168.0.0 – 192.168.255.255<h2 id="TCP-IP协议："><a href="#TCP-IP协议：" class="headerlink" title="TCP/IP协议："></a>TCP/IP协议：</h2></li>
</ul>
</li>
<li><p>Internet Protocol 、 Transmission Control Protocol</p>
</li>
<li><p>Internet最为基础和重要的协议</p>
</li>
<li><p>用于因特网Internet的一组通信协议，本质上是一种采用分组交换技术的协议，基本思想是把信息分割成一个个不超过一定大小的信息包来传送</p>
</li>
<li><p>TCP-传输控制协议，负责网上信息的正确传输</p>
</li>
<li><p>IP-网际协议，负责将信息从一处传输到另一处</p>
<h3 id="模型："><a href="#模型：" class="headerlink" title="模型："></a>模型：</h3></li>
<li><p>应用层 —- Telent、FTP和e-mail等</p>
</li>
<li><p>传输层 —- TCP和UDP</p>
</li>
<li><p>网络层 —- IP、ICMP和IGMP</p>
</li>
<li><p>网络接口层 —- 设备驱动程序及接口卡</p>
</li>
</ul>
<h2 id="域名和网址"><a href="#域名和网址" class="headerlink" title="域名和网址"></a>域名和网址</h2><p>如果要从一台计算机访问网上另一台计算机，就必须知道对方的网址，这里的网址有IP地址、域名地址和URL两种</p>
<h3 id="IP地址：-1"><a href="#IP地址：-1" class="headerlink" title="IP地址："></a>IP地址：</h3><ul>
<li><p>常见的IP地址分为IPv4和IPv6两大类，在IPv6地址的设计过程中一劳永逸的解决了地址短缺的问题，并且解决了IPv4中的其它一些问题</p>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3></li>
<li><p>为了方便记忆，Internet引入了字符形式的IP地址，即域名。每一层有一个子域名组成，子域名之间用”.”分割，其格式为：开头.主机名.主机类别.国家名(可以不要)</p>
</li>
<li><p>Internet上的域名由域名管理系统(DNS)(域名服务器)统一管理，DNS是一个分布式数据库系统，由域名空间、域名服务器、地址转换请求程序三部分组成，可以方便的转换成数值形式的IP地址进行访问，IP地址也可以反向转换成域名。在Internet上，域名和IP地址都是唯一的</p>
</li>
<li><p>顶级域名：</p>
<ul>
<li>顶级国家域名,cn\us\uk</li>
<li>国际顶级域名,int</li>
<li>通用顶级域名名,com\net\gov\edu…</li>
</ul>
</li>
</ul>
<h2 id="远程登陆："><a href="#远程登陆：" class="headerlink" title="远程登陆："></a>远程登陆：</h2><p>Telent…</p>
<h2 id="文本传输协议-FTP"><a href="#文本传输协议-FTP" class="headerlink" title="文本传输协议(FTP)"></a>文本传输协议(FTP)</h2><p>FTP是因特网上文件传输的基础，通常所说的FTP是基于该协议的一种服务，FTP文本传输协议允许因特网上的用户将一台计算机上的文件传输到另一台上，涵盖几乎所有类型的文件</p>
<h2 id="全球信息网-WWW"><a href="#全球信息网-WWW" class="headerlink" title="全球信息网(WWW)"></a>全球信息网(WWW)</h2><p>又称万维网，采用了“超文本”的技术，其网页文件是用超文本标记语言HTML写的，包含各种多媒体信息及指向其他超文本的链接</p>
<h2 id="统一资源定位器-URL"><a href="#统一资源定位器-URL" class="headerlink" title="统一资源定位器(URL)"></a>统一资源定位器(URL)</h2><p>就是因特网上的资源地址。每个web页面都有一个唯一的地址，格式为：协议名://IP地址或域名</p>
<h2 id="电子邮件及其协议"><a href="#电子邮件及其协议" class="headerlink" title="电子邮件及其协议"></a>电子邮件及其协议</h2><ul>
<li><p>简单邮件传输协议(SMTP)、电子邮件扩展协议(MIME)和POP协议。POP服务需要一个邮件服务器来提供</p>
</li>
<li><p>简单地讲：POP(POP3) - 接收，SMTP - 发送</p>
</li>
</ul>
<hr>
<h2 id="杂项-1"><a href="#杂项-1" class="headerlink" title="杂项"></a>杂项</h2><ul>
<li><p>NNTP\SMTP\POP\FTP\NNTP(网络新闻传输协议)都是Internet的服务</p>
</li>
<li><p>HTTP为超文本传输协议</p>
</li>
<li><p>电邮地址：用户名@服务器主机名</p>
</li>
<li><p>世界上第一个计算机网络：ARPA NET美国国防部高级研究计划网</p>
</li>
<li><p>对于用来说，在访问网络共享资源时候<strong>不需要</strong>考虑资源所在的物理位置</p>
</li>
<li><p>在TCP/IP网络中，数据一旦传送到目的节点，通过<strong>端口号</strong>机制可以将其传送给指定的程序</p>
</li>
<li><p>如果互联的局域网高层分别采用TCP/IP协议与SPX/IPX协议，那么我们可以选择的互联设备是<strong>路由器</strong></p>
</li>
<li><p>CERNET表示中国教育科研计算机网</p>
</li>
<li><p>TCP与UDP的区别：</p>
<ul>
<li>TCP是稳定可靠的，UDP是不稳定不可靠的</li>
<li>TCP是面向字节流的，UDP是基于数据报的</li>
<li>TCP是面向连接的，UDP是面向无连接的</li>
<li>TCP保证数据顺序，UDP不保证</li>
<li>TCP保证数据正确性，UDP可能丢包</li>
<li>UDP程序结构比较简单</li>
</ul>
</li>
<li><p>TCP的三次握手(建立连接)和四次挥手(释放)，了解即可</p>
</li>
<li><p>TCP属于传输层的协议，IP属于网络层的协议</p>
</li>
</ul>
<h1 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h1><h2 id="排序："><a href="#排序：" class="headerlink" title="排序："></a>排序：</h2><ul>
<li>稳定排序：<br>  直接插排、冒泡排序、归并排序、<strong>基数排序</strong></li>
<li>不稳定排序：<br>  希尔排序、选排、堆排、快排<h2 id="算法时间复杂度递推式计算："><a href="#算法时间复杂度递推式计算：" class="headerlink" title="算法时间复杂度递推式计算："></a>算法时间复杂度递推式计算：</h2>套用<a href="https://blog.csdn.net/lanchunhui/article/details/52451362" target="_blank" rel="noopener">主定理法</a>进行分析</li>
</ul>
<p>带log的不能用主定理，直接乘方加一即可，例如若公式中有$log$，那么直接选择$log^2$，以此类推</p>
<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h2><h2 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h2><p>另外比较好的整理</p>
<p>sto<a href="https://www.luogu.org/blog/br2014/chu-sai-zhi-shi-zheng-li" target="_blank" rel="noopener">包容</a></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>计划</tag>
        <tag>初赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra</title>
    <url>/2019/10/03/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Dijkstra/</url>
    <content><![CDATA[<h2 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h2><p>求解图论问题时经常有询问最短路的操作，Dijkstra是一种求解非负权图单源最短路径的有效算法</p>
<h2 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h2><p>以源点为起点，每次从相邻的点中<strong>扩展一个距离最近的新节点</strong>，再以这个点为<strong>中间点</strong>，<strong>更新源点到其他点的最短距离</strong>，由于边权为正，所以不会存在一个距离更短的且没有被扩展过的点，保证算法正确性</p>
<ul>
<li><p>vis数组记录是否更新s点到其他点的最短距离</p>
</li>
<li><p>dis数组记录源点到顶点i的最短距离值</p>
</li>
</ul>
<h2 id="Dijkstra求最短路："><a href="#Dijkstra求最短路：" class="headerlink" title="Dijkstra求最短路："></a>Dijkstra求最短路：</h2><p><strong>算法步骤：</strong></p>
<p>一. 根据题意选定源点s，初始化s到其他点的距离为无穷大，到自身距离为0</p>
<p>二. 重复如下操作直到所有点都被扩展过：</p>
<ol>
<li><p>选择一个未被标记的点k，vis[k] = true,刚开始k = s（源点）</p>
</li>
<li><p>以k为中间点，更新到与k相邻点i的 dis[i] (s到i的距离)</p>
</li>
<li><h2 id="选择一个新的中间点k-保证d-k-是最小的"><a href="#选择一个新的中间点k-保证d-k-是最小的" class="headerlink" title="选择一个新的中间点k,保证d[k]是最小的"></a>选择一个新的中间点k,保证d[k]是最小的</h2><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">for (int i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">/* 初始化源点到其他点的距离 */</span></span><br><span class="line">    dis[i] = inf;</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line">int k = s;</span><br><span class="line">while (!vis[k])</span><br><span class="line">&#123;</span><br><span class="line">    vis[k] = true; <span class="comment">/* 操作1 */</span></span><br><span class="line">    for (int i = head[k]; i; i = edge[i].nxt)</span><br><span class="line">        if (!vis[edge[i].to] &amp;&amp; edge[i].cost + dis[k] &lt; dis[edge[i].to])</span><br><span class="line">            dis[edge[i].to] = dis[k] + edge[i].cost;</span><br><span class="line">    minn = inf;</span><br><span class="line">    for (int i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        if (!vis[i] &amp;&amp; dis[i] &lt; minn)</span><br><span class="line">            minn = dis[i], cu = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>算法时间复杂度为O(n^2)</p>
<h2 id="Dijkstra的堆优化："><a href="#Dijkstra的堆优化：" class="headerlink" title="Dijkstra的堆优化："></a>Dijkstra的堆优化：</h2><p>堆内部结构调整操作为logn复杂度，使用堆优化O(n)的查找新k节点操作可以使整体时间复杂度降到O(nlogn)</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int u, d<span class="comment">;</span></span><br><span class="line">    <span class="keyword">bool </span>operator&lt;(const Node &amp;a) const</span><br><span class="line">    &#123;</span><br><span class="line">        return d &gt; a.d<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line">void <span class="keyword">Dijkstra(int </span>s)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = <span class="number">1</span><span class="comment">; i &lt;= n; i++)</span></span><br><span class="line">        <span class="keyword">dis[i] </span>= inf<span class="comment">;</span></span><br><span class="line">    <span class="keyword">dis[s] </span>= <span class="number">0</span><span class="comment">;</span></span><br><span class="line"><span class="symbol">    std:</span>:priority_queue&lt;Node&gt; Q<span class="comment">;</span></span><br><span class="line">    Q.push((Node)&#123;s, <span class="number">0</span>&#125;)<span class="comment">;</span></span><br><span class="line">    while (!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node fr = Q.top()<span class="comment">;</span></span><br><span class="line">        Q.pop()<span class="comment">;</span></span><br><span class="line">        int u = fr.u, d = fr.d<span class="comment">;</span></span><br><span class="line">        if (d != <span class="keyword">dis[u])</span></span><br><span class="line"><span class="keyword"> </span>           continue<span class="comment">;</span></span><br><span class="line">        for (int i = head[u]<span class="comment">; i; i = e[i].nxt)</span></span><br><span class="line">        &#123;</span><br><span class="line">            int to = e[i].to, val = e[i].val<span class="comment">;</span></span><br><span class="line">            if (<span class="keyword">dis[to] </span>&gt; <span class="keyword">dis[u] </span>+ val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">dis[to] </span>= <span class="keyword">dis[u] </span>+ val<span class="comment">;</span></span><br><span class="line">                Q.push((Node)&#123;to, <span class="keyword">dis[to]&#125;);</span></span><br><span class="line"><span class="keyword"> </span>           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>学习笔记</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S1大题备战</title>
    <url>/2019/10/02/OI/%E8%AE%AD%E7%BB%83/CSPS1%E5%A4%A7%E9%A2%98/</url>
    <content><![CDATA[<h1 id="前情提要："><a href="#前情提要：" class="headerlink" title="前情提要："></a>前情提要：</h1><p>教练为了防止我们初赛爆零而布置的几道题目</p>
<a id="more"></a>
<h1 id="评价："><a href="#评价：" class="headerlink" title="评价："></a>评价：</h1><p>这种题太水不想做 (XY)</p>
<p>哇这不就是一道傻逼题吗？你搞搞清楚 (TJ)</p>
<p>tql,赶紧% (Me)</p>
<h1 id="艰难的完成-ing-："><a href="#艰难的完成-ing-：" class="headerlink" title="艰难的完成(ing)："></a>艰难的完成(ing)：</h1><blockquote>
<h2 id="P1076-寻宝-你"><a href="#P1076-寻宝-你" class="headerlink" title="P1076 寻宝 [%你]"></a><a href="https://www.luogu.org/problem/P1076" target="_blank" rel="noopener">P1076 寻宝</a> [%你]</h2></blockquote>
<p>蒟蒻读题30min，做题1.5min，大佬们只要两分钟，题意不赘述了，大佬们肯定秒懂</p>
<p>一道纯模拟</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define int long long</span></span><br><span class="line">using namespace std<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">int n, m, a[<span class="number">10001</span>][<span class="number">101</span>], <span class="keyword">b[10001][101], </span>c[<span class="number">10001</span>], sum, k, ans, q<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">int read()</span><br><span class="line">&#123;</span><br><span class="line">    int x = <span class="number">0</span>, f = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    char ch = getchar()<span class="comment">;</span></span><br><span class="line">    while (!isdigit(ch))</span><br><span class="line">        f = (ch == <span class="string">'-'</span>) ? -<span class="number">1</span> : <span class="number">1</span>, ch = getchar()<span class="comment">;</span></span><br><span class="line">    while (isdigit(ch))</span><br><span class="line">        x = x * <span class="number">10</span> + (ch - <span class="string">'0'</span>), ch = getchar()<span class="comment">;</span></span><br><span class="line">    return x * f<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    n = read(), m = read()<span class="comment">;</span></span><br><span class="line">    for (int i = <span class="number">1</span><span class="comment">; i &lt;= n; i++)</span></span><br><span class="line">        for (int <span class="keyword">j </span>= <span class="number">0</span><span class="comment">; j &lt;= m - 1; j++)</span></span><br><span class="line">            a[i][<span class="keyword">j] </span>= read(), <span class="keyword">b[i][j] </span>= read(), c[i] += a[i][<span class="keyword">j];</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>   k = read()<span class="comment">;</span></span><br><span class="line">    for (int <span class="keyword">j </span>= <span class="number">1</span><span class="comment">; j &lt;= n; j++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum += <span class="keyword">b[j][k];</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>       ans = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">        q = k<span class="comment">;</span></span><br><span class="line">        <span class="keyword">b[j][q] </span>= (<span class="keyword">b[j][q] </span>- <span class="number">1</span>) % c[<span class="keyword">j] </span>+ <span class="number">1</span><span class="comment">;</span></span><br><span class="line">        while (ans &lt; <span class="keyword">b[j][q])</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>       &#123;</span><br><span class="line">            ans += a[<span class="keyword">j][k];</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>           if (ans == <span class="keyword">b[j][q])</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>               <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>           k++<span class="comment">;</span></span><br><span class="line">            if (k == m)</span><br><span class="line">                k = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum % <span class="number">20123</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h2 id="P1077-摆花-DP"><a href="#P1077-摆花-DP" class="headerlink" title="P1077 摆花 [DP]"></a><a href="https://www.luogu.org/problem/P1077" target="_blank" rel="noopener">P1077 摆花</a> [DP]</h2></blockquote>
<h3 id="题意简述："><a href="#题意简述：" class="headerlink" title="题意简述："></a>题意简述：</h3><p>给定n,m,a[1]…a[n]表示有n种花每种的数量不超过a[i]盆，一共可以摆m盆，求摆花的方案数，答案%19260817，呸%1e6+7;</p>
<h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><p>设f[i][j]表示前i种花摆了j盆的情况种数</p>
<p>f[i][j]=sigma_f[i-1][j-k],0&lt;=k&lt;=min(a[i],j)</p>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[maxn], f[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(j, a[i]); k++)</span><br><span class="line">                f[i][j] = (f[i][j] + f[i - <span class="number">1</span>][j - k]) % Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n][m] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h2 id="P1965-转圈游戏-数学-分治"><a href="#P1965-转圈游戏-数学-分治" class="headerlink" title="P1965 转圈游戏 [数学] [分治]"></a><a href="https://www.luogu.org/problem/P1965" target="_blank" rel="noopener">P1965 转圈游戏</a> [数学] [分治]</h2></blockquote>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给定n,m,k,x，求(x+m*10^k)%n</p>
<h3 id="思路浅析："><a href="#思路浅析：" class="headerlink" title="思路浅析："></a>思路浅析：</h3><p>根据分配律，得到原式=x%n+(m%n)*(10^k%n)，用快速幂计算出10^k%n即可</p>
<h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k, x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        f = (ch == <span class="string">'-'</span>) ? <span class="number">-1</span> : <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        x = x * <span class="number">10</span> + (ch - <span class="string">'0'</span>), ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>, t = a;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = res * t % n;</span><br><span class="line">        t = t * t % n;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=read(),m=read(),k=read(),x=read();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(x%n+m%n*QuickPow(<span class="number">10</span>,k)%n)%n&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h2 id="P1970-花匠-贪心"><a href="#P1970-花匠-贪心" class="headerlink" title="P1970 花匠 [贪心]"></a><a href="https://www.luogu.org/problem/P1970" target="_blank" rel="noopener">P1970 花匠</a> [贪心]</h2></blockquote>
<h3 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给定长为n的序列，求出最长的波动序列的长度，也就是以增减增减的形式存在的序列</p>
<h3 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h3><pre><code>input:
5
5 3 2 1 2
output:
3
(5,1,2)</code></pre><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>此题蒟蒻读完题后一口贪心结论糊中，%你要求去最大长度输出即可</p>
<h3 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">bool</span> f;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">2</span>] &gt;= a[<span class="number">1</span>])</span><br><span class="line">        f = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">false</span> &amp;&amp; i == n)</span><br><span class="line">            ans++;</span><br><span class="line">        <span class="keyword">if</span> (f)</span><br><span class="line">            <span class="keyword">if</span> (a[i + <span class="number">1</span>] &lt; a[i])</span><br><span class="line">                ans++, f = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">if</span> (a[i + <span class="number">1</span>] &gt; a[i])</span><br><span class="line">                ans++, f = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h2 id="P2058-海港-模拟"><a href="#P2058-海港-模拟" class="headerlink" title="P2058 海港 [模拟]"></a><a href="https://www.luogu.org/problem/P2058" target="_blank" rel="noopener">P2058 海港</a> [模拟]</h2></blockquote>
<h3 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h3><p>略..</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>纯模拟题，但是空间会爆，使用new int即可</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> sor[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ship</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">int</span> *people;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, n, l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        r = i; <span class="comment">//右区间</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[i].t, &amp;a[i].p);</span><br><span class="line">        a[i].people = <span class="keyword">new</span> <span class="keyword">int</span>[a[i].p]; <span class="comment">//动态数组，保证空间不被开爆；</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].p; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].people[j]);</span><br><span class="line">            sor[a[i].people[j]]++;</span><br><span class="line">            <span class="keyword">if</span> (sor[a[i].people[j]] == <span class="number">1</span>)</span><br><span class="line">                ans++; <span class="comment">//进入队列，如果还没有该国的人，+1；</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[r].t - a[l].t &gt;= <span class="number">86400</span>)</span><br><span class="line">            <span class="keyword">while</span> (a[r].t - a[l].t &gt;= <span class="number">86400</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[l].p; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    sor[a[l].people[j]]--;</span><br><span class="line">                    <span class="keyword">if</span> (sor[a[l].people[j]] == <span class="number">0</span>)</span><br><span class="line">                        ans--; <span class="comment">//退出队列</span></span><br><span class="line">                &#125;</span><br><span class="line">                l++; <span class="comment">//左区间</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h2 id="P2239-螺旋矩阵-规律-数学"><a href="#P2239-螺旋矩阵-规律-数学" class="headerlink" title="P2239 螺旋矩阵 [规律] [数学]"></a><a href="https://www.luogu.org/problem/P2239" target="_blank" rel="noopener">P2239 螺旋矩阵</a> [规律] [数学]</h2></blockquote>
<h3 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h3><pre><code>            1 2 3
给定一个形如 8 9 4的蛇形数阵，要求输出第(i,j)位置上的数字
            7 6 5</code></pre><h3 id="思路浅析：-1"><a href="#思路浅析：-1" class="headerlink" title="思路浅析："></a>思路浅析：</h3><p>P2661 信息传递</p>
<p>P2678 跳石头</p>
<p>P3951 小凯的疑惑</p>
<p>P3956 棋盘</p>
<p>P3958 奶酪</p>
<p>P1078 文化之旅</p>
<p>P1082 同余方程</p>
<p>P1351 联合权值</p>
<p>P1982 小朋友的数字</p>
<p>P2296 寻找道路</p>
<p>P2671 求和</p>
<p>P2672 推销员</p>
<p>P2822 组合数问题</p>
<p>P5018 对称二叉树</p>
<p>P5020 货币系统</p>
<p>P1080 国王游戏</p>
<p>P1083 借教室</p>
<p>P1850 换教室</p>
<p>P1941 飞扬的小鸟</p>
<p>P1955 [NOI2015]程序自动分析</p>
<p>P1966 火柴排队</p>
<p>P1967 货车运输</p>
<p>P1983 车站分级</p>
<p>P2044 [NOI2012]随机数生成器</p>
<p>P2119 魔法阵</p>
<p>P2168 [NOI2015]荷马史诗</p>
<p>P2258 子矩阵</p>
<p>P2312 解方程</p>
<p>P2668 斗地主</p>
<p>P2679 子串</p>
<p>P2827 蚯蚓</p>
<p>P2831 愤怒的小鸟</p>
<p>P3952 时间复杂度</p>
<p>P3957 跳房子</p>
<p>P5017 摆渡车</p>
<p>P5022 旅行</p>
<p>P2280 [HNOI2003]激光炸弹</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>计划</tag>
        <tag>初赛</tag>
      </tags>
  </entry>
</search>
