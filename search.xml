<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>假期之初的展望</title>
    <url>/2021/02/07/%E6%97%A5%E8%AE%B0/daily/2021.2.7/</url>
    <content><![CDATA[<p>寒假第三天，二月进度21.43%，不能称得上是展望，只是这几天过得不舒服，所以还是要整理一下。</p>
<p>唯有在做整理这件事的时候，让思绪倾泻到朦胧的vscode编辑器上，才有学校里那种笔迹划过白纸的感觉，身心舒畅<del>（这就是我物理课摸鱼的理由吗嘿嘿）</del></p>
<p>一回到家，整个人从行为上看就直接松懈了，没有沉迷游戏，但就是没有静心学习，按自己的计划来，抱着杂乱的心态东做一点西做一点，时间就这么过去，心思定制的时间表也像一个笑话一样听过算过</p>
<p>个人的情感历程纷繁复杂，到最后甚至想要不负责任的当一个渣男放纵此生，他妈谁说让生活充实起来就不会想这些有的没的了，打出去拖死！然而，还是和某个“脆弱的玻璃心女孩”在一起了，就用某人来称呼她吧，额，怎么样算在一起呢，？我又该做些什么呢？还相信爱情吗？有相信过爱情吗？这些问题真的回答不了自己，想了两天没有结果，也不强迫了，等时间给出答案吧，顿悟也要渐悟得基础</p>
<p>只是因为个人一些寡淡又难忘的经历，这份恋爱似乎没有预想的那么甜，但能让我放松下来，体验不一样的状态，高三上的思绪令人感到荒诞不经却又真实而讽刺，听着甜甜的恋爱歌，幻想有个懂我的女朋友，随心所欲又漫不经心的处理掉生活中的每一件事情，不谈钱不谈琐事不谈儿女情长，快要成仙了，和程一风唯一的区别可能就是偶尔会放浪形骸，破坏一些无伤大雅的规则了（逃自修课打球好评），而现在，虽然感觉某人可能没幻想出来的女朋友那么懂我，不过她感动人的水平还是很强的，好久都没有流过泪了，那么，想了很多，可能我还是更接受当下这种平平淡淡的生活加上偶有的快乐吧，我们都煎熬了许久，不知道她的想法，但对于那些过去，我已不在意了，也提不起感伤的情绪，能让我坚定的确认自己可以好好和她面对未来的，还是那分，再听自己的恋爱歌单，再回想自己过往经历，不一样的感觉吧</p>
<p>然后是操蛋的文化课，开学立下豪言壮志（当然只有自己知道）440，这想必是不可能的，奇怪的是无论我怎么理性分析，怎么看着首考倒计时也从119到89，到50，到15，到只剩5天，都没有放弃过这种姑且称得上是信念的感觉，<del>（于是首考367的分数我也是很有水平的，笑）</del>，所以，720，THU CS专业的flag还是要立的，反正我的惨痛经历都阻止不了我的想法，那么，语文130是异想天开（现在100撑死），数学145是“伟大构想”（8、5、3、10基础分都拿不稳，120都是问题），英语145是奇思妙想（提个三十分需要的不是勇气，是脑洞），物化100是梦中偶得（8字头都没有，shift！），技术94冲100有点机会，木得时间，难搞，这还不读书？</p>
<p>之所以有上述不可能的计划，是出于理性分析（不赘述了），觉得这些计划属实离谱，也是理性分析，但是，反正活都活了，失败也失败了，进步也进步了，就不委屈自己的想法了吧</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>2020，黑暗中的彷徨</title>
    <url>/2021/02/05/%E6%97%A5%E8%AE%B0/summary/2020/</url>
    <content><![CDATA[<p>我不知道该以什么样的表情神色去面对过去，对未来也不能再像以前一样美好而抽象的去想象</p>
<a id="more"></a>

]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>逆序对求解</title>
    <url>/2020/10/24/OI/%E9%A2%98%E8%A7%A3/%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P1908" target="_blank" rel="noopener">逆序对模板题</a></p>
<h2 id="归并排序求解逆序对："><a href="#归并排序求解逆序对：" class="headerlink" title="归并排序求解逆序对："></a>归并排序求解逆序对：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">500010</span>],c[<span class="number">500010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msort</span><span class="params">(<span class="keyword">int</span> b,<span class="keyword">int</span> e)</span></span>&#123; <span class="comment">// begin,end</span></span><br><span class="line">    <span class="keyword">if</span>(b==e)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(b+e)&gt;&gt;<span class="number">1</span>,i=b,j=mid+<span class="number">1</span>,k=b;</span><br><span class="line">    msort(b,mid),msort(mid+<span class="number">1</span>,e);</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=e)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j]) c[k++]=a[i++];</span><br><span class="line">        <span class="keyword">else</span> c[k++]=a[j++], ans+=mid-i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)c[k++]=a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=e)c[k++]=a[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=b;l&lt;=e;l++)a[l]=c[l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">    msort(<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树状数组求逆序对"><a href="#树状数组求逆序对" class="headerlink" title="树状数组求逆序对"></a>树状数组求逆序对</h2><p>树状数组怎么求逆序对？</p>
<p>根据数值建立树状数组，按照序列值从小到大排序，将数值对应的位置+1，那么<strong>有$a_i$与树状数组内比$a_i$大的数值都构成逆序对</strong>，考虑离散化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(a) ((a)&amp;(-a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c[N],r[N],n; <span class="comment">// c-树状数组,**r[i]表示原序列a[i]的位置**</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos,val;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.val==b.val?a.pos&lt;b.pos:a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> d)</span></span>&#123; <span class="keyword">for</span>(;p&lt;=n;p+=low(p)) c[p]+=d; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p;p-=low(p)) sum+=c[p];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i].val),a[i].pos=i;</span><br><span class="line">    <span class="built_in">std</span>::sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) r[a[i].pos]=i; <span class="comment">// 离散化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) add(r[i],<span class="number">1</span>),ans+=i-query(r[i]); <span class="comment">// 树状数组求逆序对</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>树状数组</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Race to 1 Again 数学期望</title>
    <url>/2020/10/24/OI/%E9%A2%98%E8%A7%A3/LightOJ1038/</url>
    <content><![CDATA[<p>给定一个$N$，N可以除以因子，问得到$1$需要的期望步数</p>
<a id="more"></a>

<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://vjudge.net/problem/LightOJ-1038" target="_blank" rel="noopener">题目</a>含义见上</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设$dp[i]$表示当前数字为$i$，变到$1$需要的期望步数</p>
<p>例：<br>$$dp[8] = \frac {(dp[1]+dp[2]+dp[4]+dp[8])}{4}+1$$</p>
<p>化简可得<br>$$dp[8] = \frac {(dp[1]+dp[2]+dp[4]+4)}{3}$$</p>
<p>这样就可以递推求解$dp[n]$</p>
<p>$$dp[n]=\frac {\Sigma_{i=1}^{k}dp[c[i]] + k}{k-1}$$</p>
<p>其中$k$是$n$的因子个数，$c[i]$是n的因子</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">double</span> f[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(f[x]) <span class="keyword">return</span> f[x];</span><br><span class="line">    <span class="keyword">double</span> tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>,i=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i*i&lt;x;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line">            tmp+=dp(i);</span><br><span class="line">            tmp+=dp(x/i);</span><br><span class="line">            num+=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i*i==x) tmp+=dp(i), num++;</span><br><span class="line">    tmp+=dp(<span class="number">1</span>),num++;</span><br><span class="line">    <span class="keyword">return</span> f[x]=(tmp+num+<span class="number">1</span>)/num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">int</span> Case=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">100010</span>;i++)&#123;</span><br><span class="line">        dp(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %.10lf\n"</span>,++Case,f[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P1352」没有上司的舞会</title>
    <url>/2020/10/24/OI/%E9%A2%98%E8%A7%A3/LGP1352%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A/</url>
    <content><![CDATA[<p>大佬们说这是树形DP基础题，蒟蒻想学树形DP…</p>
<a id="more"></a>
<h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>给定每个节点的快乐值</p>
<p>如果一个节点选择，那么它的儿子节点就不能再被选择</p>
<p>问选出的最大值是多少</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>每个节点只有选择或者不选择两种方式</p>
<p>设f[x][0]表示以x为根的树中，x不参会时最大的快乐值</p>
<p>则有：f[x][0]=sigma(max(f[s][0],f[s][1])); (s∈son[x])</p>
<p>f[x][1]表示参会时的最大分数</p>
<p>则有：f[x][1]=sigma(f[s][0])+a[i]; (s∈son[x])</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; son[<span class="number">6010</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">6010</span>][<span class="number">2</span>],v[<span class="number">6010</span>],h[<span class="number">6010</span>],n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="built_in">read</span>()&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="built_in">while</span>(!isdigit(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="built_in">while</span>(isdigit(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="built_in">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> dp(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    f[x][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    f[x][<span class="number">1</span>]=h[x];</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=son[x][i];</span><br><span class="line">        dp(y);</span><br><span class="line">        f[x][<span class="number">0</span>]+=<span class="built_in">max</span>(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>]);</span><br><span class="line">        f[x][<span class="number">1</span>]+=f[y][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">    <span class="comment">// freopen("in.in","r",stdin);</span></span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) h[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">        v[x]=<span class="number">1</span>; <span class="comment">// X has a father</span></span><br><span class="line">        son[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">if</span>(!v[i])&#123;</span><br><span class="line">            root=i;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp(root);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">max</span>(f[root][<span class="number">0</span>],f[root][<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P1082」同余方程</title>
    <url>/2020/10/24/OI/%E9%A2%98%E8%A7%A3/LGP1082%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/</url>
    <content><![CDATA[<p>线性同余方程的基础题</p>
<a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>求解$ax \equiv 1 (mod \  b)$的最小整数解</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以通过扩展欧几里得算法求解$ax+by=1$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Extend_GCD</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>,y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="keyword">int</span> d=Extend_GCD(b,a%b,x,y),tmp=x;</span><br><span class="line">    x=y,y=tmp-a/b*y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,x,y;</span><br><span class="line">    a=read(),b=read();</span><br><span class="line">    <span class="keyword">int</span> gcd=Extend_GCD(a,b,x,y);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(x+b)%b&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>乘法逆元</tag>
        <tag>扩展欧几里得</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P3366」最小生成树</title>
    <url>/2020/10/24/OI/%E6%A8%A1%E6%9D%BF/%5B%E6%A8%A1%E6%9D%BF%5D%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<p>此题有两种解法，详见博客——【学习笔记】最小生成树</p>
<a id="more"></a>

<h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal:"></a>Kruskal:</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* P3366 [模板]最小生成树 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;a.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[<span class="number">2000010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,ans,cnt;</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">5010</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x==fa[x]?x:find(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(e+<span class="number">1</span>,e+m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">    <span class="keyword">int</span> u,v,c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        u=find(e[i].u),v=find(e[i].v),c=e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;</span><br><span class="line">        ans+=c;</span><br><span class="line">        fa[u]=v;</span><br><span class="line">        <span class="keyword">if</span>(++cnt==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        e[i].u=read(),e[i].v=read(),e[i].w=read();</span><br><span class="line">    &#125;</span><br><span class="line">    Kruskal();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim:"></a>Prim:</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,cnt,ans;</span><br><span class="line"><span class="keyword">int</span> h[<span class="number">5010</span>],d[<span class="number">5010</span>];</span><br><span class="line"><span class="keyword">bool</span> v[<span class="number">5010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,val,nxt;</span><br><span class="line">&#125; e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v,e[cnt].val=c,e[cnt].nxt=h[u],h[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        x=read(),y=read(),z=read();</span><br><span class="line">        add(x,y,z),add(y,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//prim</span></span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">1</span>,tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) d[i]=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[<span class="number">1</span>];i;i=e[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].to;</span><br><span class="line">        d[y]=min(d[y],e[i].val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(++tot&lt;n)&#123;</span><br><span class="line">        <span class="keyword">int</span> minn=inf;</span><br><span class="line">        v[now]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(!v[i]&amp;&amp;minn&gt;d[i])</span><br><span class="line">                minn=d[i],now=i;</span><br><span class="line">        ans+=minn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[now];i;i=e[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> y=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(d[y]&gt;e[i].val&amp;&amp;!v[y]) d[y]=e[i].val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>最小生成树</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P5367」康托展开</title>
    <url>/2020/10/24/OI/%E6%A8%A1%E6%9D%BF/%5B%E6%A8%A1%E6%9D%BF%5D%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/</url>
    <content><![CDATA[<p>康托展开详见我的<a href="https://wyctstf.github.io/2019/10/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BA%B7%E6%8B%93%E5%B1%95%E5%BC%80/" target="_blank" rel="noopener">博文</a></p>
<a id="more"></a>

<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个序列的长度n和一组数列，保证这组数列是1-n的全排列中的一种，问这组排列在全排列中的字典序排名</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>此题用康托展开O(n^2)算法可以通过，但是鉴于严格情况下的数据以及限制，蒟蒻用的还是O(NlgN)的解法</p>
<p>一个优化思想是采用树状数组维护原数列中每一个a[i]的rank[i]的值，也就是维护区间和,其sum值就是rank值，用完之后add(i,-1)即可</p>
<p>先要O(n)维护一个阶乘的值</p>
<p>注意：不开long long见祖宗</p>
<p><del>用树状数组而不用线段树的原因：树状数组码量小</del></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">int</span> a[N],c[N],l[N],fac[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">        c[x]+=k,x+=l[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        t+=c[x];</span><br><span class="line">        x-=l[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fac[i]=fac[i<span class="number">-1</span>]*i%MOD,l[i]=i&amp;(-i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) add(i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=read();</span><br><span class="line">        ans=(ans+((sum(a[i])<span class="number">-1</span>)*fac[n-i])%MOD)%MOD;</span><br><span class="line">        add(a[i],<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数学</tag>
        <tag>树状数组</tag>
        <tag>康托展开</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P3367」并查集</title>
    <url>/2020/10/24/OI/%E6%A8%A1%E6%9D%BF/%5B%E6%A8%A1%E6%9D%BF%5D%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p>复习一波并查集的板子</p>
<a id="more"></a>

<p>想学习并查集的可以看<a href="https://oi-wiki.org/ds/dsu/" target="_blank" rel="noopener">这个</a>，UI漂亮</p>
<p>这次复习加了启发式合并以后跑的飞快</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N],fa[N],siz[N];</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="built_in">read</span>()&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="built_in">while</span>(!isdigit(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="built_in">while</span>(isdigit(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="built_in">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">find</span>(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    <span class="built_in">return</span> x==fa[x]?x:<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> merge(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=<span class="built_in">find</span>(x),fy=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="built_in">if</span>(fx==fy) <span class="built_in">return</span> ;</span><br><span class="line">    <span class="built_in">if</span>(siz[fx]&gt;siz[fy]) swap(fx,fy);</span><br><span class="line">    fa[fx]=fy;</span><br><span class="line">    siz[fy]+=siz[fx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">signed</span> main()&#123;</span><br><span class="line">    <span class="keyword">int</span> op,x,y;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i,siz[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        op=<span class="built_in">read</span>(),x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">if</span>(op==<span class="number">1</span>)</span><br><span class="line">            merge(x,y);</span><br><span class="line">        <span class="built_in">else</span></span><br><span class="line">            <span class="built_in">find</span>(x)==<span class="built_in">find</span>(y)?puts(<span class="string">"Y"</span>):puts(<span class="string">"N"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P3378」堆</title>
    <url>/2020/10/24/OI/%E6%A8%A1%E6%9D%BF/%5B%E6%A8%A1%E6%9D%BF%5D%E5%A0%86/</url>
    <content><![CDATA[<p>复习一波手写二叉堆的模板，以免初赛碰到没认出来导致场面一度尴尬</p>
<a id="more"></a>

<p>这篇<a href="https://www.cnblogs.com/henry-1202/p/9307927.html" target="_blank" rel="noopener">博客</a>写的还是不错的</p>
<h2 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h2><h3 id="插入："><a href="#插入：" class="headerlink" title="插入："></a>插入：</h3><p>将一个元素放到堆尾，比较和父节点的大小不断进行交换，一直到不满足条件为止</p>
<h3 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h3><p>直接输出堆顶，正常情况下我们都使用数组保存二叉树所以直接输出heap[1]即可</p>
<h3 id="取出堆顶元素："><a href="#取出堆顶元素：" class="headerlink" title="取出堆顶元素："></a>取出堆顶元素：</h3><p>把堆顶和堆尾交换，然后一直把堆顶向下交换即可</p>
<h2 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],n,siz;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    h[++siz]=x;</span><br><span class="line">    <span class="keyword">int</span> now=siz;</span><br><span class="line">    <span class="keyword">while</span>(now&gt;<span class="number">1</span> &amp;&amp; h[now]&lt;h[now&gt;&gt;<span class="number">1</span>])</span><br><span class="line">        swap(h[now],h[now&gt;&gt;<span class="number">1</span>]),now&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    swap(h[siz--],h[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>((now&lt;&lt;<span class="number">1</span>)&lt;=siz)&#123;</span><br><span class="line">        <span class="keyword">int</span> nxt=now&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>((nxt|<span class="number">1</span>)&lt;=siz&amp;&amp;h[nxt|<span class="number">1</span>]&lt;h[nxt]) nxt++;</span><br><span class="line">        <span class="keyword">if</span>(h[nxt]&lt;h[now]) swap(h[now],h[nxt]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        now=nxt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op,x;</span><br><span class="line">    n=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        op=read();</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            x=read();</span><br><span class="line">            ins(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;h[<span class="number">1</span>]&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>二叉堆</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P3388」割点</title>
    <url>/2020/10/24/OI/%E6%A8%A1%E6%9D%BF/%5B%E6%A8%A1%E6%9D%BF%5D%E5%89%B2%E7%82%B9/</url>
    <content><![CDATA[<p>割点的模板</p>
<a id="more"></a>

<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt,num,root,sum;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N];</span><br><span class="line"><span class="keyword">int</span> head[N],ver[N*<span class="number">5</span>],nxt[N*<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> cut[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    ver[++cnt]=y,nxt[cnt]=head[x],head[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    dfn[x]=low[x]= ++num;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            tarjan(y);</span><br><span class="line">            low[x]=min(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;=dfn[x])&#123;</span><br><span class="line">                flag++;</span><br><span class="line">                <span class="comment">/* 如果不是根节点或者是根节点并且满足条件的y的num&gt;=2 */</span></span><br><span class="line">                <span class="keyword">if</span>(x!=root || flag&gt;<span class="number">1</span>) cut[x]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x]=min(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        x=read(),y=read();</span><br><span class="line">        <span class="keyword">if</span>(x==y) <span class="keyword">continue</span>;</span><br><span class="line">        add(x,y),add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) &#123;root=i,tarjan(i);&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cut[i]) sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cut[i]) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P3865」ST表</title>
    <url>/2020/10/24/OI/%E6%A8%A1%E6%9D%BF/%5B%E6%A8%A1%E6%9D%BF%5DST%E8%A1%A8/</url>
    <content><![CDATA[<p>倍增模板题之一</p>
<a id="more"></a>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定n个数和m个询问</p>
<p>每次询问有一个左右区间l,r</p>
<p>问区间内的最大值</p>
<p>要求每次查询时间复杂度为O(1)</p>
<h3 id="思路浅析"><a href="#思路浅析" class="headerlink" title="思路浅析"></a>思路浅析</h3><p>设f[i][j]表示表示以第i个数为起点，长度为2^j的区间[i,i+(2^j)-1]维护的信息，递推边界显然是f[i][0]=a[i]</p>
<p>在递推时，将区间长度成倍增长，则有f[i][j]=max/min{f[i][j-1],f[i+2^j][j-1]}</p>
<p>即把一个长度为2^j的区间分解成两部分来统计</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N],f[N][<span class="number">20</span>],lg[N]=&#123;<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=read();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i][<span class="number">0</span>]=a[i],lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lg[n];j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-(<span class="number">1</span>&lt;&lt;j)+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            f[i][j]=max(f[i][j<span class="number">-1</span>],f[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=lg[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> max(f[l][k],f[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ask</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        l=read(),r=read();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;query(l,r)&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    input();</span><br><span class="line">    pre();</span><br><span class="line">    ask();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机</title>
    <url>/2020/10/24/OI/%E6%A8%A1%E6%9D%BF/%5B%E6%A8%A1%E6%9D%BF%5DAC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<p>AC自动机是一种多模式串匹配算法，其时间复杂度与模式串总长度成正比</p>
<a id="more"></a>

<p>学习笔记的话推荐两篇比较好的blog</p>
<p><a href="https://oi.men.ci/acam-notes/" target="_blank" rel="noopener">menci</a></p>
<p><a href="https://oi-wiki.org/string/ac-automaton/" target="_blank" rel="noopener">oi-wiki</a></p>
<p>总的思想就是建立Trie树，然后利用KMP的思想建立失配指针指针，加快单个字符串查询速度，只要学会<strong>Trie</strong>和<strong>KMP</strong>，还是比较好理解的，这里直接给出洛谷基础模板题的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> AC &#123;</span><br><span class="line">    <span class="keyword">int</span> tot, e[N], fail[N], tr[N][<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; s[i]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!tr[u][s[i] - <span class="string">'a'</span>]) tr[u][s[i] - <span class="string">'a'</span>] = ++tot;</span><br><span class="line">            u = tr[u][s[i] - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        e[u]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) <span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tr[u][i]) fail[tr[u][i]] = tr[fail[u]][i], q.push(tr[u][i]);</span><br><span class="line">                <span class="keyword">else</span> tr[u][i] = tr[fail[u]][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; t[i]; i++) &#123;</span><br><span class="line">            u = tr[u][t[i] - <span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = u; j &amp;&amp; e[j] != <span class="number">-1</span>; j=fail[j]) &#123;</span><br><span class="line">                res += e[j], e[j] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>), AC::insert(s);;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    AC::build();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; AC::query(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>字符串</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2020/10/24/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>在解题时常需要维护一个数组的前缀信息，一旦涉及区间修改，一次操作就是O ( n )级别的，这里我们需要具有树形结构的树状数组来减小修改的操作数</p>
<a id="more"></a>
<h2 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h2><p>任意整数表示为二进制数时都是不同的，因此我们可以将x二进制分解，例如21可以分解成2^4+2^2+2^0，也就是说，[ 1 , x ]的区间可以分解成 log ( x )的小区间，以21为例：</p>
<ol>
<li>[ 1 , 2 ^ 4 ]的小区间</li>
<li>[ 2 ^ 4 + 1 , 2 ^ 4 + 2 ^ 2 ] 的小区间</li>
<li>[ 2 ^ 4 + 2 ^ 2 + 1 , 2 ^ 4 + 2 ^ 2 + 2 ^ 0 ]的小区间</li>
</ol>
<p>树状数组就是一种基于上述思想的数据结构，基本用途是维护序列的前缀信息，通过类似树形结构一样的分界区间，满足快速单点修改和区间和查询</p>
<h2 id="基本算法："><a href="#基本算法：" class="headerlink" title="基本算法："></a>基本算法：</h2><p>由上文可知，若区间结尾为R，那么区间长度就等于R的二进制分解下的最小的2的次幂，我们设为lowbit ( R )<br>对于给定序列A，建立数组c，其中c [ x ]保存序列A的区间[ x - lowbit ( x ) + 1 , x ]中的区间和<br><img src="https://img2018.cnblogs.com/blog/1576249/201908/1576249-20190801202345653-2102085685.png" alt></p>
<p>该结构满足以下性质：</p>
<ol>
<li>每个内部节点c [ x ]保存以它为根的子树中所有叶节点和</li>
<li>每个内部节点c [ x ]的子节点个数等于lowbit ( x )的位数</li>
<li>除了树根之外，每个内部节点的c [ x ]的父节点是c [ x + lowbit ( x ) ]</li>
<li>树的深度为O( logN  )</li>
</ol>
<p>由上图得出一个规律：<br><strong>C[ i ] = A[ i - 2 ^ k+1 ] + A[ i - 2 ^ k + 2 ] + … + A[ i ];   k为i的二进制中从最低位到高位连续零的长度，也就是lowbit ( i )</strong></p>
<h2 id="1-求lowbit-n"><a href="#1-求lowbit-n" class="headerlink" title="1.求lowbit( n )"></a>1.求lowbit( n )</h2><p>lowbit( n )表示取出非负整数n在二进制表示下最低位的1以及它后边的0构成的数值，<strong>lowbit ( n ) = n &amp; ( - n )</strong><br>证明过程：<br>设n &gt; 0,n的第k位是1,0 —- k - 1位都是0</p>
<ul>
<li><p>先将n取反，此时第k位变为0，0 —- k-1位为 1</p>
</li>
<li><p>n += 1，由于进位的关系，0 —- k位数值不变，n的第k+1位到最高位与原来相反</p>
</li>
<li><p>再进行按位&amp;操作，得到长度相同的部分，答案为 n &amp; (  ~ n + 1 )</p>
</li>
<li><p>在补码表示下 ~n = -1 - n，因此lowbit( n ) = n &amp; ( - n )</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="keyword">return</span> x &amp; (-n); &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-单点修改操作："><a href="#2-单点修改操作：" class="headerlink" title="2. 单点修改操作："></a>2. 单点修改操作：</h2><p>给序列中的某个数A[ x ] 加上y，同时维护正确的前缀和，根据上述的树形结构和性质，只有节点c[ x ]及其所有祖先节点保存的区间和包含A[ x ]，而任意一个节点的祖先至多有logN个，所以时间复杂度可以保证</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= N)</span><br><span class="line">    &#123;</span><br><span class="line">        c[x] += y; <span class="comment">/* 当前祖先节点更新 */</span></span><br><span class="line">        x += lowbit( x ); <span class="comment">/* 往上一祖先更新 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-查询前缀和："><a href="#3-查询前缀和：" class="headerlink" title="3. 查询前缀和："></a>3. 查询前缀和：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += c[x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-二维树状数组"><a href="#4-二维树状数组" class="headerlink" title="4. 二维树状数组"></a>4. 二维树状数组</h2><h3 id="单点修改："><a href="#单点修改：" class="headerlink" title="单点修改："></a>单点修改：</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">int update(int x, int y, int z)</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="built_in">i</span> = x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">i</span> &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        int <span class="built_in">j</span> = y;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">j</span> &lt;= m)</span><br><span class="line">        &#123;</span><br><span class="line">            c[<span class="built_in">i</span>][<span class="built_in">j</span>] += z;</span><br><span class="line">            <span class="built_in">j</span> += lowbit(<span class="built_in">j</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">i</span> += lowbit(<span class="built_in">i</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区间和统计："><a href="#区间和统计：" class="headerlink" title="区间和统计："></a>区间和统计：</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">int sum(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    int res = <span class="number">0</span>, <span class="built_in">i</span> = x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">i</span> &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        int <span class="built_in">j</span> = y;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">j</span> &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res += c[<span class="built_in">i</span>][<span class="built_in">j</span>];</span><br><span class="line">            <span class="built_in">j</span> -= lowbit(<span class="built_in">j</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">i</span> -= lowbit(<span class="built_in">i</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-区间修改-amp-单点查询（差分数组）："><a href="#5-区间修改-amp-单点查询（差分数组）：" class="headerlink" title="5. 区间修改 &amp; 单点查询（差分数组）："></a>5. 区间修改 &amp; 单点查询（差分数组）：</h2><p>当一段区间需要修改的时候，单纯的O(m)遍历是无法满足复杂度要求的，最坏情况可能都不如普通数组有效，因此我们需要一个技巧<strong>差分建树</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">50005</span>] = &#123;<span class="number">0</span>&#125;, c[<span class="number">50005</span>]; <span class="comment">//对应原数组和树状数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//在i位置加上k</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += k;</span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//求D[1 - i]的和，即A[i]值</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res += c[i];</span><br><span class="line">        i -= lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        updata(i, a[i] - a[i - <span class="number">1</span>]); <span class="comment">//输入初值的时候，也相当于更新了值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[x,y]区间内加上k</span></span><br><span class="line">    updata(x, k);      <span class="comment">//A[x] - A[x-1]增加k</span></span><br><span class="line">    updata(y + <span class="number">1</span>, -k); <span class="comment">//A[y+1] - A[y]减少k</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询i位置的值</span></span><br><span class="line">    <span class="keyword">int</span> sum = getsum(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-区间修改、区间查询"><a href="#6-区间修改、区间查询" class="headerlink" title="6. 区间修改、区间查询"></a>6. 区间修改、区间查询</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">50005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum1[<span class="number">50005</span>]; <span class="comment">//(D[1] + D[2] + ... + D[n])</span></span><br><span class="line"><span class="keyword">int</span> sum2[<span class="number">50005</span>]; <span class="comment">//(1*D[1] + 2*D[2] + ... + n*D[n])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = i; <span class="comment">//因为x不变，所以得先保存i值</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        sum1[i] += k;</span><br><span class="line">        sum2[i] += k * (x - <span class="number">1</span>);</span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//求前缀和</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, x = i;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res += x * sum1[i] - sum2[i];</span><br><span class="line">        i -= lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        updata(i, a[i] - a[i - <span class="number">1</span>]); <span class="comment">//输入初值的时候，也相当于更新了值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[x,y]区间内加上k</span></span><br><span class="line">    updata(x, k);      <span class="comment">//A[x] - A[x-1]增加k</span></span><br><span class="line">    updata(y + <span class="number">1</span>, -k); <span class="comment">//A[y+1] - A[y]减少k</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//求[x,y]区间和</span></span><br><span class="line">    <span class="keyword">int</span> sum = getsum(y) - getsum(x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="That’s-all"><a href="#That’s-all" class="headerlink" title="That’s all."></a>That’s all.</h1>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>学习笔记</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2020/10/24/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<p>点开洛谷模板题一看原来是抄了题解，吓得赶紧重新学习</p>
<a id="more"></a>
<h1 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h1><p>最小生成树(MST)是指在一个节点数量为n的<strong>无向图</strong>中的一个由<strong>n-1</strong>条边构成的<strong>连通子图</strong>并且<strong>边权和最小</strong></p>
<h1 id="Kruskal算法："><a href="#Kruskal算法：" class="headerlink" title="Kruskal算法："></a>Kruskal算法：</h1><h2 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h2><p>对所有边进行排序，用并查集维护连通性，从小到大选择边，判断是否构成一个环，如果不是则加入，否则放弃</p>
<h2 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h2><ol>
<li><p>建立并查集，每个节点各自构成一个集合</p>
</li>
<li><p>所有边的边权按照权值从小到大排序，依次扫描每一条边(x,y,z)</p>
</li>
<li><p>如果x,y属于同一集合，那么忽略这条边</p>
</li>
<li><p>否则合并x,y，把z累加到答案中</p>
</li>
</ol>
<p>所有的边扫描完成之后，就构成了一棵MST</p>
<p>时间复杂度为O(m logm)</p>
<p>据说适用于稀疏图</p>
<h1 id="Prim算法："><a href="#Prim算法：" class="headerlink" title="Prim算法："></a>Prim算法：</h1><h2 id="算法思路：-1"><a href="#算法思路：-1" class="headerlink" title="算法思路："></a>算法思路：</h2><ul>
<li><p>最初，确定节点1在MST中</p>
</li>
<li><p>和Dijkstra相似(不知道的可以略过这句话)，以1为当前节点不断找到与当前节点距离最短的节点，使用一个v[N]数组进行标记，如果没有到过该节点，那么就收入到MST中,ans+=dis[now][to]</p>
</li>
<li><p>采用一个d[N]数组记录当前节点到各个节点的距离值，在收入节点与当前节点的转移中不断更新</p>
</li>
</ul>
<p>所有的点被收入之后，就生成了一棵MST</p>
<p>时间复杂度为O(N^2)，可以通过堆优化降低复杂度到O(m logn)，但是编程复杂度就不如Kruskal优秀，因此适用于稠密图，尤其是完全图的最小生成树求解</p>
<p>模板题详见博客——【洛谷 P3366】【模板】最小生成树(持续更新ing)</p>
]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>算法模板</tag>
        <tag>学习笔记</tag>
        <tag>最小生成树</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>康托展开</title>
    <url>/2020/10/24/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BA%B7%E6%8B%93%E5%B1%95%E5%BC%80/</url>
    <content><![CDATA[<p>康托展开用于求解一个全排列在所有全排列中的排名</p>
<a id="more"></a>

<h2 id="举栗"><a href="#举栗" class="headerlink" title="举栗"></a>举栗</h2><p>对于1-4的一个全排列{1，2，3，4}和{4，3，2，1}，我们知道，就字典序而言，第一个排列是全排列里的第一个，后者是最后一个排列</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩</p>
<p>它的实质是计算当前排列在所有字典序由小到大全排列中的名次，是可逆的，也就是可以根据排名而求出这个排列</p>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>给定一个数列a[n]</p>
<blockquote>
<p><strong>X=A[0] * (n-1)!+A[1] * (n-2)!+…+A[n-1] * 0!</strong></p>
</blockquote>
<p>A[i]指的是位于位置i后面的数小于a[i]值的个数</p>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释:"></a>解释:</h2><p>以{2，3，4，1}来说明</p>
<ol>
<li><p>初始字典序为0</p>
</li>
<li><p>第一位是2，那么以1打头的所有全排列一定排在这个全排列之前，rank=rank+1*3！，3！指的是剩下的数有3!的排列情况</p>
</li>
<li><p>第二位是3，那么与1、2作为第二位的所有全排列就一定在这个之前，但已经让2打头了，不需要再考虑2占第二位的情况，只需要计算1占第二位的情况，rank+=1*2!</p>
</li>
<li><p>第三位是4，同理rank+=1*1!</p>
</li>
<li><p>最后一位就不用判定了，当然为了格式也可以有rank+=0*0!</p>
</li>
<li><p>最后答案+1即可，因为第一个排列的排名是1</p>
</li>
</ol>
<p>在步骤3中，可以看到，实际考虑的情况是比3小并且位置没有固定&lt;==&gt;之前的序列里没有出现&lt;==&gt;出现在之后的序列里，那么真正干扰的也就是a[i]在i+1—n个数内的排名</p>
<p>至此公式解释完毕</p>
<blockquote>
<h3 id="模板题-【洛谷P5367】康托展开"><a href="#模板题-【洛谷P5367】康托展开" class="headerlink" title="模板题-【洛谷P5367】康托展开"></a><a href="https://www.luogu.org/problem/P5367" target="_blank" rel="noopener">模板题-【洛谷P5367】康托展开</a></h3></blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p>WXY教练PPT中的关于康拓展开的一页</p>
</li>
<li><p>网上一位大佬的<a href="https://blog.csdn.net/ajaxlt/article/details/86544074" target="_blank" rel="noopener">博文</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>「单调队列」</title>
    <url>/2020/10/24/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="例题引入"><a href="#例题引入" class="headerlink" title="例题引入"></a>例题引入</h2><p>给定一个长度为N的序列，从中找出一段长度不超过M的连续子序列，使得和最大</p>
<h2 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h2><p>维护一个前缀和$s[i]$，枚举左右端点$j$，$i$，使得$s[i]-s[j-1]尽可能地大$，时间复杂度为O(nm)</p>
<p>发现对于每一个$k \in [j,i]，如果s[k]&lt;=s[j]$，那么相比$j$，$k$显然是一个更好的选择</p>
<p>不难发现，对于每一个右端点$i$，可能成为最优策略的左端点<strong>策略集合</strong>一定是一个<strong>下标位置递增，维护的值也单调</strong>，此处就是维护前缀和单调<strong>递增</strong>的情况</p>
<p>考虑<strong>使用一个队列维护左端点的下标值</strong>，对应当前队头的决策<strong>不满足条件</strong>(此处为超出限定的长度M)，我们才<strong>退而求其次</strong>的选择一个次优解，这就是原题中维护前缀和递增的原因</p>
<p>可以证明，对于每个$q.front()$，对之后长度不超过M的右端点的最优左端点都成立</p>
<p>随着右端点向后扫描，对每个$i$执行下述三个操作：</p>
<ol>
<li>判断队头决策与$i$的距离是否超出M，若超出则出队</li>
<li>此时队头决策就是右端点为$i$时，对左端点$j$的最优选择</li>
<li>不断删除队尾决策，直到$s[q.tail()]\leq s[i]$，i作为一个新的决策入队</li>
</ol>
<h3 id="如何理解第三步操作？"><a href="#如何理解第三步操作？" class="headerlink" title="如何理解第三步操作？"></a>如何理解第三步操作？</h3><p>对于$i$之前的序列，都得到过最优解，那么他们也可以作为左端点备用选择，放到队尾，因为维护了一个单调性队列，可以确保轮到i作为队头决策时，$i$是最优选择</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">while</span>(<span class="selector-tag">s</span><span class="selector-attr">[q.front()]</span>&gt;<span class="selector-tag">s</span><span class="selector-attr">[i]</span>) <span class="selector-tag">q</span><span class="selector-class">.pop_back</span>();</span><br><span class="line"><span class="selector-tag">q</span><span class="selector-class">.push_back</span>(<span class="selector-tag">i</span>)</span><br></pre></td></tr></table></figure>

<p>上述代码就维护了单调性</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define int long long</span></span><br><span class="line">using namespace std;</span><br><span class="line">const <span class="keyword">int</span> N=<span class="number">1</span>e5+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,<span class="keyword">m</span>,front,back,ans;</span><br><span class="line"><span class="keyword">int</span> a[N],<span class="string">q[N]</span>,<span class="keyword">s</span>[N];</span><br><span class="line">signed main()&#123;</span><br><span class="line">    scanf(<span class="string">"%lld%lld"</span>,&amp;n,&amp;<span class="keyword">m</span>);</span><br><span class="line">    front=back=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        scanf(<span class="string">"%lld"</span>,a+i),<span class="keyword">s</span>[i]=<span class="keyword">s</span>[i-<span class="number">1</span>]+a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(front&lt;=back &amp;&amp; <span class="keyword">s</span>[<span class="string">q[back]</span>-<span class="number">1</span>]&gt;<span class="keyword">s</span>[i])&#123;</span><br><span class="line">            back--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">q[++back]</span>=i-<span class="number">1</span>;</span><br><span class="line">        // cout&lt;&lt;<span class="string">q[back]</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">        ans=max(ans,<span class="keyword">s</span>[i]-<span class="keyword">s</span>[<span class="string">q[back]</span>-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span>(i-<span class="string">q[front]</span>&gt;<span class="keyword">m</span>) front++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单调性参考例题："><a href="#单调性参考例题：" class="headerlink" title="单调性参考例题："></a>单调性参考例题：</h2><ul>
<li><a href="https://www.luogu.org/problem/P1886" target="_blank" rel="noopener">P1886 滑动窗口</a></li>
<li><a href="https://www.luogu.org/problem/P2422" target="_blank" rel="noopener">P2422 良好的感觉</a></li>
</ul>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>初级线段树</title>
    <url>/2020/10/24/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%BA%A7%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<blockquote>
<p>线段树是一种基于分治思想的二叉树结构，用于在区间上的信息统计。与按照二进制位进行区间划分的树状数组相比，线段树是一种更加通用的数据结构；</p>
</blockquote>
<a id="more"></a>
<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><ol>
<li>线段树的每一个节点都代表一个区间</li>
<li>线段树具有唯一的根节点，代表的区间是整个统计范围([1,N])</li>
<li>线段树的每个叶节点都代表一个长度为1的元区间[x,x]</li>
<li>对于每个<strong>内部节点[l,r],它的左儿子节点是[l,mid]，右儿子节点是[mid+1,r]，其中mid为floor((l+r)/2)</strong></li>
<li>使用线段树统计，必须满足信息分配原理<ul>
<li>满足区间加法：<ul>
<li>区间求和</li>
<li>区间最大公因数</li>
<li>区间最值</li>
</ul>
</li>
<li>不满足：<ul>
<li>区间众数</li>
<li>01序列最长连续0</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="source/images/SegmentTree.png" alt></p>
<h2 id="相关操作："><a href="#相关操作：" class="headerlink" title="相关操作："></a>相关操作：</h2><h3 id="建树和维护"><a href="#建树和维护" class="headerlink" title="建树和维护:"></a>建树和维护:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans[N&lt;&lt;<span class="number">2</span>]; <span class="comment">// 空间开到4倍大小，因为总共有n*2-1个节点，叶节点还需要支配两个没有意义但有实际作用的节点，一共需要4*n-1个节点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>;&#125; <span class="comment">// inline 排除无效信息,ls &lt;--&gt; left son</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;&#125; <span class="comment">// 位运算加速</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up_sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 维护区间和</span></span><br><span class="line">    t[x]=t[ls(x)]+t[rs(x)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up_max</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 维护区间最值</span></span><br><span class="line">    t[x]=max(t[ls(x)],t[rs(x)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;ans[x]=a[x];<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 向下递归建树</span></span><br><span class="line">    build(ls(x),l,mid);</span><br><span class="line">    build(rs(x),mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="comment">// 回溯时通过子节点向上维护父亲节点</span></span><br><span class="line">    push_up_max(x);</span><br><span class="line">    push_up_sum(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单点修改："><a href="#单点修改：" class="headerlink" title="单点修改："></a>单点修改：</h3><p>形如一条”C x v”的指令，表示把a[x]的值修改为y;</p>
<p>在线段树中，根节点是执行各种指令的入口。我们需要从根节点出发，我们从根节点出发，递归找到代表区间[x,x]的叶节点，然后从下向上更新[x,x]以及它的所有的祖先节点上保存的信息，时间复杂度为O(nlogn)</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">void change(<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> v)&#123; <span class="comment">// r-root</span></span><br><span class="line">    <span class="keyword">if</span>(t[<span class="keyword">ls</span>(p)]==t[rs(p)])&#123;</span><br><span class="line">        a[r]=v;<span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(a[<span class="keyword">ls</span>(r)]+a[rs(r)])&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) change(<span class="keyword">ls</span>(r),x,v);</span><br><span class="line">    <span class="keyword">else</span> change(rs(r),x,v);</span><br><span class="line">    push_up_max(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区间修改："><a href="#区间修改：" class="headerlink" title="区间修改："></a>区间修改：</h3><p>如果像单点修改一样，那么<strong>总时间复杂度为O(n^2logn)，甚至不如O(n^2)</strong>，因此我们引入一个操作——<strong>懒标记</strong></p>
<p>懒标记的作用是记录每次每个节点要更新的值，记为delta，但是全记录的话复杂度就会爆炸，所以需要传递式记录，如果后续没有查询操作，那么就不着急全记录，可以等待信息的整合之后，到了要查询的情况再下传至底部，再重新上传更新所统计信息(区间和、区间最值等等)</p>
<ul>
<li><p>此过程可视为push_up的反向思路，但不是反向操作</p>
</li>
<li><p>若整个区间都被操作，那么记录在公共祖先节点上，如果只修改了一部分，那么就记录在这部分的祖先节点上面，如果只修改了自己，那么就只改变自己</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123; <span class="comment">//打标记，更新信息，以k为参数区间修改</span></span><br><span class="line">    tag[p]+=k;</span><br><span class="line">    ans[p]=ans[p]+k*(r-l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123; <span class="comment">//标记下传</span></span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    f(ls(p),l,mid,tag[p]);</span><br><span class="line">    f(rs(p),mid+<span class="number">1</span>,r,tag[p]);</span><br><span class="line">    tag[p]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> k)</span></span>&#123; <span class="comment">//x,y为待修改区间,k为修改权值</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123; <span class="comment">//如果完全覆盖</span></span><br><span class="line">        ans[p]+=k*(r-l+<span class="number">1</span>);</span><br><span class="line">        tag[p]+=k; <span class="comment">//需要下传，打标记</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(p,l,r); <span class="comment">//标记下传</span></span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>（x&lt;=mid) change(x,y,l,mid,ls(p),k); <span class="comment">// 如果左区间超过当前区间的左区间</span></span><br><span class="line">    <span class="keyword">if</span>（y&gt;mid) change(x,y,mid+<span class="number">1</span>,r,rs(p),k); <span class="comment">// 同上</span></span><br><span class="line">    push_up(p); <span class="comment">//更新信息，上传</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区间查询："><a href="#区间查询：" class="headerlink" title="区间查询："></a>区间查询：</h3><p>继续采用分块的思想，简单易懂</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> P)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y) <span class="keyword">return</span> ans[p]; <span class="comment">//如果完全覆盖，那么返回所有的信息</span></span><br><span class="line">    push_down(p,l,r); <span class="comment">// 标记下传，因为信息的整合，所以可以有效节省时间</span></span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) res+=query(x,y,l,mid,ls(p)); <span class="comment">// 分左右区间查询</span></span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) res+=query(x,y,mid+<span class="number">1</span>,r,rs(p));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里我们就可以过掉：</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P3372" target="_blank" rel="noopener">[洛谷 P3372]线段树1</a></p>
</blockquote>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><blockquote>
<ul>
<li>《算法竞赛进阶指南》</li>
<li><a href="https://www.luogu.org/blog/pks-LOVING/senior-data-structure-qian-tan-xian-duan-shu-segment-tree" target="_blank" rel="noopener">洛谷日报#4 浅谈线段树</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>基础二分图</title>
    <url>/2020/10/24/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>二分图是一种常见的图论模型</p>
<a id="more"></a>

<h2 id="二分图基础知识"><a href="#二分图基础知识" class="headerlink" title="二分图基础知识"></a>二分图基础知识</h2><ul>
<li><p>二分图可以分成左右两个点集，所有的边都连着$U<br>$到$V$</p>
</li>
<li><p>二分图中没有奇环</p>
</li>
<li><p>匹配：是一些边的集合，任意两条边没有公共顶点</p>
</li>
<li><p>最大匹配：所有匹配中边数最多的匹配</p>
</li>
<li><p>完美匹配：所有的点都在匹配中</p>
</li>
<li><p>二分图最大匹配算法：匈牙利算法</p>
</li>
<li><p>匹配点：盖点|非匹配点：未盖点</p>
</li>
<li><p>匹配边、匹配点：在一个匹配中的边和点</p>
</li>
</ul>
<h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>假设已经有了一个匹配，比较和最大匹配的差距</p>
<p>连接两端未盖的匹配边</p>
<p>然后在原图基础上找增广路，<strong>找不到说明是最大匹配</strong></p>
<p>从一侧的未盖点走增广路，也就是匹配边|非匹配边|匹配边|非匹配边的走法，如果可以走到另一侧的未盖点，那么就找到了一条增广路</p>
<p><strong>已经匹配的点永远不会退出匹配</strong>，只会更换匹配</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未匹配的增广路</span></span><br><span class="line"><span class="meta">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;er<span class="string">'fen'</span>tu</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1010</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; edge[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> mx[N], my[M];</span><br><span class="line"><span class="keyword">bool</span> visy[M];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span>(<span class="params"><span class="keyword">int</span> x</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= m; t++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[x][t] == <span class="number">1</span> &amp;&amp; !visy[t]) &#123;</span><br><span class="line">            visy[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(my[t] == <span class="number">-1</span> || dfs(my[t]) ) &#123;</span><br><span class="line">                mx[x] = t;</span><br><span class="line">                my[t] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_match</span>(<span class="params"><span class="keyword">int</span> n, <span class="keyword">int</span> m</span>)</span> &#123;</span><br><span class="line">    fill(mx, mx + n, <span class="number">-1</span>);</span><br><span class="line">    fill(my, my + m, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        fill(visy, visy + m, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (dfs(i)) &#123;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    x = y;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">    edge[x].push_back(y);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="洛谷模板：二分图匹配"><a href="#洛谷模板：二分图匹配" class="headerlink" title="洛谷模板：二分图匹配"></a>洛谷模板：<a href="https://www.luogu.org/problem/P3386" target="_blank" rel="noopener">二分图匹配</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, e, f[N]; <span class="comment">// f[i]表示对于一个右侧端点的左端匹配点</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;N&gt; vis; <span class="comment">// bitset优化常数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : edge[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[v] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!f[v] || dfs(f[v])) &#123; <span class="comment">// 增广</span></span><br><span class="line">            f[v] = u;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;e);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= e; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="keyword">if</span>(u &gt; n || v &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">        edge[u].push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        vis.reset();</span><br><span class="line">        ans += dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题：飞行员配对染色方案"><a href="#例题：飞行员配对染色方案" class="headerlink" title="例题：飞行员配对染色方案"></a>例题：<a href="https://www.luogu.org/problem/P2756" target="_blank" rel="noopener">飞行员配对染色方案</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N * N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt, ans;</span><br><span class="line"><span class="keyword">int</span> h[N], ver[M], nxt[M];</span><br><span class="line"><span class="keyword">int</span> mx[N], my[N];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;N&gt; vis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ver[++cnt] = v, nxt[cnt] = h[u], h[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!my[y] || dfs(my[y])) &#123;</span><br><span class="line">            my[y] = u, mx[u] = y;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n, u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span> &amp;&amp; v == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        add(u, v), add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) vis.reset(), ans += dfs(i);</span><br><span class="line">    m==<span class="number">0</span> ? <span class="built_in">puts</span>(<span class="string">"Nod Solution"</span>) : <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span>(mx[i]) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i, mx[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分图最小点覆盖"><a href="#二分图最小点覆盖" class="headerlink" title="二分图最小点覆盖"></a>二分图最小点覆盖</h2><p>给定一个二分图，求在节点上最少安排几个守卫使得所有的边都能被监控到，一个节点可以经过所有经过这个点的边</p>
<h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><blockquote>
<p>二分图最小点覆盖等于二分图最大匹配包含的边数</p>
</blockquote>
<ul>
<li>证明</li>
</ul>
<p>最大匹配是原二分图边集的一个子集，并且所有边不相交，所以至少要从每条匹配边中选出一个端点。</p>
<p>因此，最小点覆盖包含的点数不可能小于最大匹配包含的边数，如果能对任意二分图构造出一组点覆盖，那么定理就得证</p>
<ul>
<li><p>构造方法</p>
<ol>
<li>求出二分图最大匹配</li>
<li>从每个左部非匹配点出发，执行DFS找增广路，标记访问过的节点</li>
<li>取左部未被标记的点、右部被标记的点，就得到了二分图最小点覆盖</li>
</ol>
</li>
<li><p>证明</p>
<ol>
<li>匹配边一定被覆盖</li>
<li>不存在连接两个非匹配点的边，否则存在增广路</li>
<li>连接左部非匹配点i、右部匹配点j的边：j一定被访问，这样的边被覆盖</li>
<li>连接左部匹配点i，右部非匹配点j的边同理</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>乘法逆元</title>
    <url>/2020/10/24/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/</url>
    <content><![CDATA[<p>顾名思义，就是模意义下乘法运算的逆元</p>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如果一个线性同余方程$ax\equiv 1\ (mod \ b)$，则$x$称为$a$对$b$的逆元，记作$a^{-1}$</p>
<h2 id="Section1-扩欧"><a href="#Section1-扩欧" class="headerlink" title="Section1 - 扩欧"></a>Section1 - 扩欧</h2><blockquote>
<p>本质和解线性同余方程一样</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123; <span class="comment">// 扩欧可以返回ax+by=gcd(a,b)的一组整数解</span></span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>,y=<span class="number">0</span>;<span class="keyword">return</span> a; <span class="comment">// 返回特解x=1,y=0并正常的求解gcd</span></span><br><span class="line">    <span class="keyword">int</span> res=exgcd(b,a%b,x,y);</span><br><span class="line">    <span class="keyword">int</span> tmp=x;</span><br><span class="line">    x=y,t=tmp-(a/b)*y;</span><br><span class="line">    <span class="keyword">return</span> res; <span class="comment">// 同时返回gcd值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">exgcd_inv</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d,x,y;</span><br><span class="line">    d=exgcd(a,n,x,y);</span><br><span class="line">    <span class="keyword">return</span> d==<span class="number">1</span>?(x+n)%n:<span class="number">-1</span>; <span class="comment">// -1表示没有乘法逆元</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Section2-费马小定理"><a href="#Section2-费马小定理" class="headerlink" title="Section2 - 费马小定理"></a>Section2 - 费马小定理</h2><blockquote>
<p>当$p$为质数时(使用条件)，有$a^{p-1}\equiv 1 \ (mod \ p)$，可变为$a*a^{p-2} \equiv 1 \ (mod \ p)$，此时$a^{p-2}就是$a$对$p$的乘法逆元$</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">QuickPow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=b;</span><br><span class="line">    <span class="keyword">for</span>(;a;a&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&amp;<span class="number">1</span>)</span><br><span class="line">            ans=(ans*b%p);</span><br><span class="line">        ans=ans*ans%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fermat_inv</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QuickPow(a,n<span class="number">-2</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种线性筛逆元的解法，等哪天有时间补上，先复习初赛续命…</p>
<hr>
<p><a href="https://www.luogu.org/problem/P1082" target="_blank" rel="noopener">模板1</a></p>
<p><a href="https://www.luogu.org/problem/P3811" target="_blank" rel="noopener">模板2</a></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>数论</tag>
        <tag>乘法逆元</tag>
        <tag>扩展欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title>Tarjan杂谈</title>
    <url>/2020/10/24/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Tarjan/</url>
    <content><![CDATA[<h1 id="Part1-无向图的割点-割边"><a href="#Part1-无向图的割点-割边" class="headerlink" title="$Part1$ 无向图的割点\割边"></a>$Part1$ 无向图的割点\割边</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>给定无向图$G \in (V,E)$</p>
<p>若对于$x \in V$，从图中删去$x$以及所有与$x$关联的边之后，$G$分裂成两个及以上不相连的子图，则称$x$是$G$的<strong>割点</strong></p>
<p>若对于$e \in E$，从图中删去$e$之后，$G$分裂成两个不相连的子图，则称$e$为$G$的<strong>桥或割边</strong></p>
<hr>
<p>Tarjan基于无向图的DFS</p>
<hr>
<h2 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h2><ul>
<li><p>时间戳</p>
<p>  在图的DFS过程中，按照每个节点第一次被访问的时间顺序一次给予$1 \to N$的标，该标记被称为 $时间戳$，记为dfn[x]</p>
</li>
<li><p>搜索树</p>
<p>  从无向图中任选一个节点出发DFS，每个节点只访问一次，所有发生递归的边构成一棵树，称为<strong>无向连通图的搜索树</strong>，一般无向图的各个连通块的搜索树构成无向图的<strong>搜索森林</strong></p>
</li>
<li><p>追溯值</p>
<blockquote>
<p>low[x]表示节点$x$的追溯值</p>
</blockquote>
<p>  设$subtree(x)$表示搜索树中以$x$为根节点的子树，$low[x]$为以下节点的dfn的最小值</p>
<ol>
<li><p>$subtree(x)$中的节点</p>
</li>
<li><p>通过一条不在搜索树上的边，能够到达$subtree(x)$的节点</p>
<p>计算$low[x]$时先令$low[x]=dfn[x]$，然后考虑每条从$x$出发的边$(x,y)$:</p>
</li>
<li><p>若在搜索树上$x$是$y$的父节点，则令$low[x]\ = min(low[x],low[y])$</p>
</li>
<li><p>若无向边$(x,y)$不是搜索树上的边，则令$low[x]=min(low[x],dfn[y])$</p>
</li>
</ol>
</li>
</ul>
<h2 id="割边的判定："><a href="#割边的判定：" class="headerlink" title="割边的判定："></a>割边的判定：</h2><blockquote>
<p>无向边$(x,y)$是桥，当且仅当搜索树上存在x的一个子结点y，满足:<br>$$dfn[x]&lt;low[y]$$</p>
</blockquote>
<h2 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h2><p>根据定义，$dfn[x]&lt;low[y]$说明从$subtree(y)$出发，在不经过$(x,y)$的前提下，不管走哪条边，都无法到达$x$或比$x$更早访问的节点。</p>
<p>若把$(x,y)$删除，$subtree(y)$封闭</p>
<h2 id="一些问题以及解决方法"><a href="#一些问题以及解决方法" class="headerlink" title="一些问题以及解决方法"></a>一些问题以及解决方法</h2><p>遍历的是无向图，所以从每个节点$x$出发，总能访问到它的父节点$fa$,$fa$是搜索树上的边，但不是x的子节点，故不能用$fa$的时间来更新$low[x]$</p>
<p>但是仅仅记录每个节点的父节点，将无法处理重边，当$x$与$fa$之间有多条边时，$(x,fa)$一定不是桥，在重边中，只有一条算是“搜索树上的边”，其他的几条都不算。</p>
<p>故有重边的时候，$dfn[fa]$可以用来更新$low[x]$</p>
<p>一个比较好的解决方法是：</p>
<p>改为记录“递归进入每个节点的边的编号”。编号可理解为在邻接表中存储的边的下标的位置</p>
<p>这里需要用到“成对变换”的技巧，也就是如果进入了编号为$x$的边，则忽略编号为$x \ xor \ 1$的边</p>
<p>通过其他的边计算$low[x]$即可</p>
<p>下面给出代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,tot,num;</span><br><span class="line"><span class="keyword">int</span> h[N],ver[N&lt;&lt;<span class="number">1</span>],nxt[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N];</span><br><span class="line"><span class="keyword">bool</span> bridge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> in_edge)</span></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++num; <span class="comment">// 初始化low[x]=dfn[x]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            tarjan(y,i);</span><br><span class="line">            low[x]=min(low[x],low[y]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;dfn[x])</span><br><span class="line">                bridge[i]=bridge[i^<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i!=(in_edge^<span class="number">1</span>))</span><br><span class="line">            low[x]=min(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        x=read(),y=read(),add(x,y),add(y,x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) tarjan(i,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;tot;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bridge[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ver[i^<span class="number">1</span>],ver[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="割点的判定："><a href="#割点的判定：" class="headerlink" title="割点的判定："></a>割点的判定：</h2><p>若$x$不是搜索树的根节点($DFS$起点)，则$x$是割点当且仅当搜索树上存在$x$的一个子节点$y$，满足：<br>$$dfn[x]\  \leq \ low[y]$$</p>
<p>特别的，若$x$是搜索树的根节点，则$x$是搜索树的根节点，则$x$是割点当且仅当搜索树上存在至少两个子节点$y1,y2$满足上述条件</p>
<h2 id="请自己尝试证明，方法与割边证明过程相似"><a href="#请自己尝试证明，方法与割边证明过程相似" class="headerlink" title="请自己尝试证明，方法与割边证明过程相似"></a>请自己尝试证明，方法与割边证明过程相似</h2><h2 id="P3388-模板-割点-代码实现："><a href="#P3388-模板-割点-代码实现：" class="headerlink" title="P3388[模板]割点 代码实现："></a><a href="https://www.luogu.org/problem/P3388" target="_blank" rel="noopener">P3388[模板]割点</a> 代码实现：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,rt; <span class="comment">// rt--root</span></span><br><span class="line"><span class="keyword">int</span> cnt,num;</span><br><span class="line"><span class="keyword">int</span> h[N],ver[N&lt;&lt;<span class="number">1</span>],nxt[N&lt;&lt;<span class="number">1</span>]; <span class="comment">// 邻接表建图</span></span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N]; <span class="comment">// 相应的dfn、追溯值</span></span><br><span class="line"><span class="keyword">bool</span> cut[N]; <span class="comment">// 判断是否为割点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    ver[++cnt]=v,nxt[cnt]=h[u],h[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[x];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">            Tarjan(y); <span class="comment">// 递归搜边</span></span><br><span class="line">            low[x]=min(low[x],low[y]); <span class="comment">// 更新low[x]</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;=dfn[x])&#123;</span><br><span class="line">                flag++;</span><br><span class="line">                <span class="keyword">if</span>(x!=rt || flag&gt;<span class="number">1</span>) cut[x]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x]=min(low[x],dfn[y]); <span class="comment">// (x,y)不是搜索树上的边</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        x=read(),y=read();</span><br><span class="line">        <span class="keyword">if</span>(x==y) <span class="keyword">continue</span>;</span><br><span class="line">        add(x,y),add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) rt=i,Tarjan(i);</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(cut[i]) sum++;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cut[i]) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="无向图Tarjan经典例题"><a href="#无向图Tarjan经典例题" class="headerlink" title="无向图Tarjan经典例题"></a>无向图Tarjan经典例题</h2><h3 id="BZOJ-1123-BLO"><a href="#BZOJ-1123-BLO" class="headerlink" title="[BZOJ-1123]BLO"></a><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1123" target="_blank" rel="noopener">[BZOJ-1123]BLO</a></h3><p><a href="https://www.luogu.org/problem/P3469" target="_blank" rel="noopener">你谷链接</a></p>
<blockquote>
<p>题面：</p>
</blockquote>
<p>给定一张无向图，求每个点被封锁之后有多少个<strong>有序</strong>点对(x,y)(x!=y,1&lt;=x,y&lt;=n)满足x无法到达y</p>
<p>你需要输出$n$个整数，其中第$i$个整数表示把与节点$i$关联的所有边去掉之后(不去掉节点$i$本身)，无向图中有多少个有序点对$(x,y)$，满足$x$和$y$不连通</p>
<p>$N \leq 10^5, M \leq 10^5$</p>
<blockquote>
<p>解法：</p>
</blockquote>
<p>根据割点的定义</p>
<p>若$i$不是割点，那么删边操作之后，只有$i$与其他$n-1$个节点不同，对答案贡献为$2*(n-1)$</p>
<p>若$i$是割点，那么删边操作之后，图分成若干连通块。求出这些连通块的大小，两两相乘再相加。设在搜索树上，节点$i$的子节点集合中，有$t$个点满足$dfn[i]&lt;=low[s_k]$。<br>于是删除$i$关联的所有边之后，无向图至多分成$t+2$个连通块，每个连通块节点构成情况为：</p>
<ol>
<li>节点$i$自身单独构成一个连通块</li>
<li>有$t$个连通块，分别由<strong>搜索树上</strong>以$s_k$($1 \leq k \leq t$)为根的子树中的节点构成</li>
<li>可能还有一个连通块，由除了上述节点之外的所有点构成</li>
</ol>
<p>因此可以在$Tarjan$算法执行DFS的过程中，求出搜索树每棵”子树”的大小$size[x]$。<br>那么删除割点i之后，不连通的有序对数量为： </p>
<p>$\Sigma _{i=1}^t$ $size[s_i]*(n-size[s_i])$ $+$ $(n-1)+(n-1- \Sigma _{k=1}^t size[s_k])$ * $(1+ \Sigma _{k=1}^t size[s_k])$</p>
<blockquote>
<p>代码实现：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt,num;</span><br><span class="line"><span class="keyword">int</span> h[N],ver[M&lt;&lt;<span class="number">1</span>],nxt[M&lt;&lt;<span class="number">1</span>]; <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],siz[N],ans[N];</span><br><span class="line"><span class="keyword">bool</span> cut[N]; <span class="comment">// 割点判定</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    ver[++cnt]=v,nxt[cnt]=h[u],h[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    siz[x]=<span class="number">1</span>;</span><br><span class="line">    dfn[x]=low[x]=++num;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[x];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            tarjan(y);</span><br><span class="line">            siz[x]+=siz[y];</span><br><span class="line">            low[x]=min(low[x],low[y]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;=dfn[x])&#123;</span><br><span class="line">                flag++;</span><br><span class="line">                ans[x]+=siz[y]*(n-siz[y]);</span><br><span class="line">                sum+=siz[y];</span><br><span class="line">                <span class="keyword">if</span>(x!=<span class="number">1</span> || flag&gt;<span class="number">1</span>) cut[x]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x]=min(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cut[x]) ans[x]+=(n-sum<span class="number">-1</span>)*(sum+<span class="number">1</span>)+(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> ans[x]=<span class="number">2</span>*(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        x=read(),y=read();</span><br><span class="line">        <span class="keyword">if</span>(x==y) <span class="keyword">continue</span>;</span><br><span class="line">        add(x,y),add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cerr&lt;&lt;"fuck"&lt;&lt;endl;</span></span><br><span class="line">    tarjan(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Part2-有向图的缩点"><a href="#Part2-有向图的缩点" class="headerlink" title="$Part2$ 有向图的缩点"></a>$Part2$ 有向图的缩点</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>给定有向图$G=(V,E)$，若存在$r \in V$，满足从$r$出发可以到达所有的节点，那么$G$是一张<strong>流图</strong>，钦定$r$为源点</p>
<p>在一张流图上从$r$开始DFS，也可以生成流图的搜索树，对应的有<strong>时间戳</strong>$dfn[x]$</p>
<p>流图中的每条有向边$(x,y)$必然是以下四种之一：</p>
<ol>
<li>树枝边，即搜索树中的边，即$x$是$y$的父节点</li>
<li>前向边，即搜索树中$x$是$y$的祖先节点</li>
<li>后向边</li>
<li>横叉边，一定满足$dfn[y]&lt;dfn[x]$</li>
</ol>
<h2 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h2><p>给定一个有向图，若对于图中任意两个节点$x,y$都能相互到达，那么称该图为<strong>强连通图</strong>。</p>
<p>有向图的极大强连通子图成为强连通分量<strong>SCC</strong></p>
<p>如果$x$，$y$可以相互到达，那么肯定在一个环中</p>
<ul>
<li>通过一条后向边，那么就满足一个环的成立</li>
<li>如果$x$，$y$之间有一条横叉边，那么就要视情况而定，如果从$y$出发可以找到一条返回$x$的祖先的路径，那么这条边也是有用的</li>
</ul>
<p>为了找后向边和横叉边构成的环，Tarjan算法在DFS的同时维护了一个栈。当访问到节点$x$，需要记录一下两类节点：</p>
<ol>
<li>搜索树上$x$的祖先节点，记为集合$anc(x)$，设$y \in anc(x)$。若存在后向边(x,y)，则$(x,y)$和$y$到$x$的路径一起形成环。</li>
<li>已经访问过，并且存在一条路径到达$anc(x)$的节点。</li>
</ol>
<p>设$z$是这样的一个点，从$z$出发存在一条路径到达$y \in anc(x)$。若存在横叉边$(x,z)$，则上述的边形成一个环</p>
<h3 id="追溯值"><a href="#追溯值" class="headerlink" title="追溯值"></a>追溯值</h3><p>设$subtree(x)$表示流图的搜索树中以$x$为根的子树。$x$的追溯值$low[x]$定义为满足以下条件节点的最小时间戳：</p>
<ol>
<li>该点在栈中</li>
<li>存在一条从$subtree(x)$出发的有向边|后向边，以该点为终点</li>
</ol>
<p>根据定义，Tarjan算法按照一下步骤计算追溯值：</p>
<ol>
<li>当节点第一次被访问时，把$x$入栈，初始化$low[x]=dfn[x]$</li>
<li>扫描从$x$出发的每条边$(x,y)$。<ol>
<li>若$y$没被访问过，说明(x,y)是树枝边，递归访问$y$，从$y$回溯之后，令$low[x]=min(low[x],low[y])$。</li>
<li>若$y$被访问过并且$y$在栈中，则令$low[x]=min(low[x],dfn[y])$</li>
</ol>
</li>
<li>从$x$回溯之前，判断是否有$low[x]=dfn[x]$。若成立，则不断从栈中弹出节点知道$x$出栈</li>
</ol>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> ver[M],nxt[M],h[N];</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[N],ins[N],c[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;SCC[N];</span><br><span class="line"><span class="keyword">int</span> n,m,cnt,num,top,tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    ver[++cnt]=v,nxt[cnt]=h[u],h[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++num;</span><br><span class="line">    <span class="built_in">stack</span>[++top]=x,ins[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> y=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            tarjan(y);</span><br><span class="line">            low[x]=min(low[x],low[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ins[y])</span><br><span class="line">            low[x]=min(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[x]==low[x])&#123;</span><br><span class="line">        tot++,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            y=<span class="built_in">stack</span>[top--],ins[y]=<span class="number">0</span>;</span><br><span class="line">            c[y]=tot,SCC[tot].push_back(y);</span><br><span class="line">        &#125;<span class="keyword">while</span>(x!=y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        x=read(),y=read();</span><br><span class="line">        add(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) tarjan(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
        <tag>割点</tag>
      </tags>
  </entry>
  <entry>
    <title>Manacher</title>
    <url>/2020/10/24/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/manacher/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个长度为$n$的字符串，要求找出所有对$(i,j)$使得子串$s[i…j]$为一个回文串</p>
<p>最坏情况下有$O(n^2)$个回文串</p>
<h2 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h2><p>引入一种表达回文串的方式：</p>
<p>对于每个位置$i=0…n-1$，有$d_1[i]$和$d_2[i]$分别表示以$i$为中心的长度为奇数和长度为偶数的回文串个数</p>
<p>例如，对于字符串$a b a b a c$，有</p>
<p>$$d_1[3] = 3$$</p>
<p>这里单个字符本身也算作一个回文串</p>
<p>对于字符串$cbaabd$，有</p>
<p>$$d_2[3] = 2$$</p>
<p>显然，如果以某个位置$i$为中心，若有长度为$l$的回文串，那么就存在长度为$l-2$、$l-4$的回文串</p>
<p>则$d_1[]$和$d_2[]$两个数组就可以描述字符串中的所有回文串信息</p>
<h2 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h2><p>可以在$O(n^2)$的时间内计算出答案</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; d1(n), d2(n);</span><br><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; n; <span class="built_in">i</span>++) &#123;</span><br><span class="line">  d1[<span class="built_in">i</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span> &lt;= <span class="built_in">i</span> - d1[<span class="built_in">i</span>] &amp;&amp; <span class="built_in">i</span> + d1[<span class="built_in">i</span>] &lt; n &amp;&amp; s[<span class="built_in">i</span> - d1[<span class="built_in">i</span>]] == s[<span class="built_in">i</span> + d1[<span class="built_in">i</span>]]) &#123;</span><br><span class="line">    d1[<span class="built_in">i</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  d2[<span class="built_in">i</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span> &lt;= <span class="built_in">i</span> - d2[<span class="built_in">i</span>] - <span class="number">1</span> &amp;&amp; <span class="built_in">i</span> + d2[<span class="built_in">i</span>] &lt; n &amp;&amp;</span><br><span class="line">         s[<span class="built_in">i</span> - d2[<span class="built_in">i</span>] - <span class="number">1</span>] == s[<span class="built_in">i</span> + d2[<span class="built_in">i</span>]]) &#123;</span><br><span class="line">    d2[<span class="built_in">i</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>01分数规划</title>
    <url>/2020/10/24/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>01分数规划是二分答案中的一类常见问题</p>
<a id="more"></a>
<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>给你n对元素vi,wi,要求从中挑选出k对，使得，v的和除以w的和最大</p>
<h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p>假设我们已经求得了这个最大的值 x = sigma v [ i ] / sigma w [ i ] ;</p>
<p>则有</p>
<p>sigma(v [ i ] ) / sigma(w [ i ] ) &gt;= x -&gt; sigma(v [ i ] - x * w [ i ] ) &gt;= 0</p>
<p>在数据确定的情况下，这个式子具有单调性，所以我们可以考虑二分求解这个x值</p>
<h2 id="经典例题："><a href="#经典例题：" class="headerlink" title="经典例题："></a>经典例题：</h2><h3 id="POJ-3111-K-Best"><a href="#POJ-3111-K-Best" class="headerlink" title="POJ 3111 K Best"></a><a href="http://poj.org/problem?id=3111" target="_blank" rel="noopener">POJ 3111 K Best</a></h3><p>模板题..</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v[maxn], w[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> val;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; a.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        f = (ch == <span class="string">'-'</span>) ? <span class="number">-1</span> : <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        x = x * <span class="number">10</span> + (ch - <span class="string">'0'</span>), ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        f[i].val = v[i] - x * w[i], f[i].id = i + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::sort(f, f + n);</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += f[i].val;</span><br><span class="line">        ans[i] = f[i].id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), k = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        v[i] = read(), w[i] = read();</span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">0</span>, r = INF;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">1e-8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid))</span><br><span class="line">            l = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f[i].id;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k - <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>学习笔记</tag>
        <tag>01分数规划</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>「CF 739B」Alyona and a tree</title>
    <url>/2020/10/24/OI/Codeforces/CF739B/</url>
    <content><![CDATA[<p>一道树形结构经典题，感觉蒟蒻这辈子都没法在比赛的时候切Div.1的题目ler</p>
<a id="more"></a>

<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一棵树，每个节点和边都有一个值，任取一个节点u，在它的子树中任取一个v，若dis(u,v) &lt; val[v]，那么我们说u控制了v，要求输出每个节点控制的节点数目</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>正常的DFS肯定会爆炸，我们考虑O(n)DFS统计信息，然后树上倍增+树上差分统计每个节点控制的节点数，因为距离值具有单调性可以倍增跳节点</p>
<h2 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"><span class="keyword">int</span> n,cnt;</span><br><span class="line"><span class="keyword">int</span> a[N],d[N],f[N][<span class="number">25</span>],ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> to,nxt;&#125; e[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f=<span class="number">1</span>,x=<span class="number">0</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span>  x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;e[++cnt].to=v,e[cnt].nxt=h[u],h[u]=cnt;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    d[u]+=d[fa],f[u][<span class="number">0</span>]=fa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i;i=e[i].nxt) dfs(e[i].to,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;<span class="keyword">return</span> d[u]-d[v];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i;i=e[i].nxt)&#123;</span><br><span class="line">        solve(e[i].to,k);</span><br><span class="line">        ans[u]+=ans[e[i].to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        u=read(),v=read();</span><br><span class="line">        d[i]+=v;</span><br><span class="line">        add(u,i);</span><br><span class="line">    &#125;</span><br><span class="line">    d[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i][j]=f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">20</span>;j&gt;=<span class="number">0</span>;j--)&#123; <span class="comment">// 倍增跳节点</span></span><br><span class="line">            <span class="keyword">if</span>(dis(i,f[pos][j])&lt;=a[i]) pos=f[pos][j];</span><br><span class="line">        &#125;</span><br><span class="line">        ans[f[pos][<span class="number">0</span>]]--,ans[f[i][<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    solve(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title>「NOIP2016」蚯蚓 队列+二叉堆</title>
    <url>/2019/11/11/OI/%E9%A2%98%E8%A7%A3/NOIP2016%E8%9A%AF%E8%9A%93/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P2827" target="_blank" rel="noopener">题目传送门</a></p>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。<br>蛐蛐国里现在共有 $n$ 只蚯蚓（$n$ 为正整数）。每只蚯蚓拥有长度，我们设第 $i$ 只蚯蚓的长度为 $a_i$<br>  ($1 \leq i \leq n$)，并保证所有的长度都是非负整数（即：可能存在长度为 $0$ 的蚯蚓）。</p>
<p>每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数 $p$（是满足 $0&lt;p&lt;1$ 的有理数）决定，设这只蚯蚓长度为 $x$，神刀手会将其切成两只长度分别为 $\lfloor px \rfloor$ 和 $x - \lfloor px \rfloor$ 的蚯蚓。如果这两个数的其中一个等于 $0$，则这个长度为 $0$ 的蚯蚓也会被保留。除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加 $q$（是一个非负整常数）。</p>
<p>蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 $m$ 秒才能到来……（$m$ 为非负整数）</p>
<p>蛐蛐国王希望知道这 $m$ 秒内的战况。具体来说，他希望知道：</p>
<p>$m$ 秒内，每一秒被切断的蚯蚓被切断前的长度（有 $m$ 个数）；<br>$m$ 秒后，所有蚯蚓的长度（有 $n + m$ 个数）。<br>蛐蛐国王当然知道怎么做啦！但是他想考考你……</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含六个整数 $n,m,q,u,v,t$，其中$n,m,q$见题目描述，需要自己计算$p=u/v$，$t$为输出参数</p>
<p>第二行包含$n$个非负整数，为$a_1,a_2,\dots,a_n$，即初始时$n$只蚯蚓的长度</p>
<p>保证$1\leq n\leq 10^5$,$0\leq m\leq 7*10^6$,$0&lt;u&lt;v\leq 10^9$,$0\leq q\leq 200$,$1\leq t\leq10^7$,$0\leq a_i \leq10^8$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>第一行输出$\lfloor{\frac m t}\rfloor$个整数，按时间顺序输出，依次输出第$t$秒，第$2t$秒，第$3t$秒，$\dots$被斩断蚯蚓的长度</p>
<p>第二行输出$\lfloor \frac {n+m} t\rfloor$个整数，输出$m$秒后蚯蚓的长度；需要从大到小的排序，依次输出排名第$t$，$2t$，$\dots$的长度</p>
<p>同一行中相邻的两个数之间，恰好用一个空格隔开。即使某一行没有任何数需要输出，你也应输出一个空行。</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>如果$q=0$，即蚯蚓不会变长，那么本题相当于维护一个集合支持最大值查询 | 删除最大值 | 插入新的值，这个使用二叉堆或者平衡树$STL \ \ set$就可以做到，时间复杂度为$O(m\ logn)$</p>
<p>当$q&gt;0$时，除了最大值拆成的两个数之外，集合中的其他数都会增加$q$。设最大值为x，我们不妨认为产生了两个大小为$\lfloor{px}\rfloor-q$和$n-\lfloor{px}\rfloor-q$的新数，再把整个集合加上$q$</p>
<p>可以维护一个偏移量$delta$，集合中的数加上$delta$就是真实数值</p>
<p>但是，仅仅按照上述的方法进行$m$轮模拟肯定会T飞</p>
<p>设$x_1,x_2$为非负整数，当$x_1\geq x_2$时，有$\lfloor{px_1}\rfloor+q\geq\lfloor{px_2}\rfloor+pq$</p>
<p>可理解为$\lfloor{px_1+q}\rfloor\geq\lfloor{p(x_2+q)}\rfloor$</p>
<p>又因为有<br>$$x_1-x_2\geq p(x_1-x_2)$$</p>
<p>所以有<br>$$x_1-px_1\geq x_2-px_2\geq x_2-p(x_2+q)$$</p>
<p>进一步有</p>
<p>$$x_1-\lfloor{px_1}\rfloor+q=\lfloor{x_1-px_1}\rfloor+q\geq \lfloor{x_2-p(x_2+q)}\rfloor+q=x_2+q-\lfloor{p(x_2+q)}\rfloor$$</p>
<p>意义是：若$x_1$在$x_2$前被取出集合，则在一秒后，$x_1$分成两个数$\lfloor{px_1}\rfloor+q$和$x-1-\lfloor{px_1}\rfloor+q$分别不小于$x_2$分成的两个数$\lfloor{p(x_2+q)}\rfloor$和$x_2+q-\lfloor{p(x_2+q)}\rfloor$</p>
<p>那么，不仅从集合中取出的数是单调递减的，新产生的两类数值也是随时间单调递减的</p>
<p>我们建立三个队列$A,B,C$</p>
<p>A维护初始的n个数，从大到小排序，队列$B$保存每秒新产生的$\lfloor{px}\rfloor$的那一段数值。队列$C$保存1剩下的一类数值，单调性保证数据的顺序同步，此时集合中最大的数就是队列$A,B,C$的三个队首之一，配合集合的偏移量$delta$，整个算法的时间复杂度为$O(m+nlogn)$</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* PP2728 蚯蚓 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt;q1;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q2,q3;</span><br><span class="line"><span class="keyword">int</span> n,m,q,u,v,t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxLen</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1=<span class="number">-1</span>,x2=<span class="number">-1</span>,x3=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!q1.empty()) x1=q1.top()+t*q;</span><br><span class="line">    <span class="keyword">if</span>(!q2.empty()) x2=q2.front()+t*q;</span><br><span class="line">    <span class="keyword">if</span>(!q3.empty()) x3=q3.front()+t*q;</span><br><span class="line">    <span class="keyword">if</span>(x1&gt;=x2 &amp;&amp; x1&gt;=x3)&#123;q1.pop();<span class="keyword">return</span> x1;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x2&gt;=x1&amp;&amp;x2&gt;=x3)&#123;q2.pop();<span class="keyword">return</span> x2;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;q3.pop();<span class="keyword">return</span> x3;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("earthworm.in","r",stdin);</span></span><br><span class="line">    <span class="comment">// freopen("earthworm.out","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>,&amp;n,&amp;m,&amp;q,&amp;u,&amp;v,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="keyword">int</span> x;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x),q1.push(x);&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> t1,t2,len=MaxLen(i<span class="number">-1</span>);</span><br><span class="line">        t1=len*u/v;t2=len-t1;</span><br><span class="line">        q2.push(t1-i*q);q3.push(t2-i*q);</span><br><span class="line">        <span class="keyword">if</span>(i%t==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;len&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m+n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> len=MaxLen(m);</span><br><span class="line">        <span class="keyword">if</span>(i%t==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;len&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二叉堆</tag>
        <tag>思维</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P3373」线段树1</title>
    <url>/2019/10/09/OI/%E6%A8%A1%E6%9D%BF/%5B%E6%A8%A1%E6%9D%BF%5D%E7%BA%BF%E6%AE%B5%E6%A0%911/</url>
    <content><![CDATA[<p>线段树模板题，详情参阅博文 【学习笔记】初级线段树，这里不再赘述，直接给出代码</p>
<a id="more"></a>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">/* <span class="symbol">P3372</span> [模板]线段树<span class="number">1</span> */</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define <span class="built_in">int</span> long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const <span class="built_in">int</span> <span class="built_in">N</span>=<span class="number">1</span>e5+<span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> <span class="built_in">n</span>,m,a[<span class="built_in">N</span>];</span><br><span class="line">struct Node&#123;</span><br><span class="line">    <span class="built_in">int</span> l,r,<span class="built_in">sum</span>,add;</span><br><span class="line">&#125;<span class="built_in">t</span>[<span class="built_in">N</span>&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">void build(<span class="built_in">int</span> p,<span class="built_in">int</span> l,<span class="built_in">int</span> r)&#123;</span><br><span class="line">    <span class="built_in">t</span>[p].l=l,<span class="built_in">t</span>[p].r=r;</span><br><span class="line">    <span class="built_in">if</span>(l==r)&#123;</span><br><span class="line">        <span class="built_in">t</span>[p].<span class="built_in">sum</span>=a[l];return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">mid</span>=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(p&lt;&lt;<span class="number">1</span>,l,<span class="built_in">mid</span>);</span><br><span class="line">    build(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,<span class="built_in">mid</span>+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">t</span>[p].<span class="built_in">sum</span>=<span class="built_in">t</span>[p&lt;&lt;<span class="number">1</span>].<span class="built_in">sum</span>+<span class="built_in">t</span>[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].<span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline <span class="built_in">int</span> read()&#123;</span><br><span class="line">    <span class="built_in">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="built_in">char</span> ch=getchar();</span><br><span class="line">    while(!isdigit(ch)) f=(ch=='-')?-<span class="symbol">1:1</span>,ch=getchar();</span><br><span class="line">    while(isdigit(ch)) x=x*<span class="number">10</span>+(ch-'<span class="number">0</span>'),ch=getchar();</span><br><span class="line">    return x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void f(<span class="built_in">int</span> p,<span class="built_in">int</span> k)&#123;</span><br><span class="line">    <span class="built_in">t</span>[p].add+=k; // 为什么是+=而不是=可以思考一下</span><br><span class="line">    <span class="built_in">t</span>[p].<span class="built_in">sum</span>+=k*(<span class="built_in">t</span>[p].r-<span class="built_in">t</span>[p].l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void push_down(<span class="built_in">int</span> p)&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">mid</span>=(<span class="built_in">t</span>[p].l+<span class="built_in">t</span>[p].r)&gt;&gt;<span class="number">1</span>; // 标记下传</span><br><span class="line">    f(p&lt;&lt;<span class="number">1</span>,<span class="built_in">t</span>[p].add);</span><br><span class="line">    f(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,<span class="built_in">t</span>[p].add);</span><br><span class="line">    <span class="built_in">t</span>[p].add=<span class="number">0</span>; // 清空本身标记</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void change(<span class="built_in">int</span> p,<span class="built_in">int</span> x,<span class="built_in">int</span> y,<span class="built_in">int</span> k)&#123;</span><br><span class="line">    <span class="built_in">if</span>(x&lt;=<span class="built_in">t</span>[p].l&amp;&amp;<span class="built_in">t</span>[p].r&lt;=y) &#123;f(p,k);return ;&#125;</span><br><span class="line">    push_down(p);</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">mid</span>=(<span class="built_in">t</span>[p].l+<span class="built_in">t</span>[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">if</span>(x&lt;=<span class="built_in">mid</span>) change(p&lt;&lt;<span class="number">1</span>,x,y,k);</span><br><span class="line">    <span class="built_in">if</span>(y&gt;<span class="built_in">mid</span>) change(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y,k);</span><br><span class="line">    <span class="built_in">t</span>[p].<span class="built_in">sum</span>=<span class="built_in">t</span>[p&lt;&lt;<span class="number">1</span>].<span class="built_in">sum</span>+<span class="built_in">t</span>[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].<span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> query(<span class="built_in">int</span> p,<span class="built_in">int</span> x,<span class="built_in">int</span> y)&#123;</span><br><span class="line">    <span class="built_in">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">if</span>(x&lt;=<span class="built_in">t</span>[p].l&amp;&amp;<span class="built_in">t</span>[p].r&lt;=y)&#123;</span><br><span class="line">        return <span class="built_in">t</span>[p].<span class="built_in">sum</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(p); // 因为要查询，必须向下传递，如果左右儿子也要查询，那么自然会继续下传，否则就不用下传，这就是懒标记的省时之处</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">mid</span>=(<span class="built_in">t</span>[p].l+<span class="built_in">t</span>[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">if</span>(x&lt;=<span class="built_in">mid</span>) res+=query(p&lt;&lt;<span class="number">1</span>,x,y);</span><br><span class="line">    <span class="built_in">if</span>(y&gt;<span class="built_in">mid</span>) res+=query(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,y);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    <span class="built_in">n</span>=read(),m=read();</span><br><span class="line">    for(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">n</span>;i++) a[i]=read();</span><br><span class="line">    build(<span class="number">1</span>,<span class="number">1</span>,<span class="built_in">n</span>);</span><br><span class="line">    <span class="built_in">int</span> op,x,y,k;</span><br><span class="line">    for(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        op=read(),x=read(),y=read();</span><br><span class="line">        <span class="built_in">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            k=read();</span><br><span class="line">            change(<span class="number">1</span>,x,y,k);</span><br><span class="line">        &#125;</span><br><span class="line">        else cout&lt;&lt;query(<span class="number">1</span>,x,y)&lt;&lt;'\n';</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P2043」质因子分解</title>
    <url>/2019/10/08/OI/%E9%A2%98%E8%A7%A3/LGP2043%E8%B4%A8%E5%9B%A0%E5%AD%90%E5%88%86%E8%A7%A3/</url>
    <content><![CDATA[<p>对N!进行质因子分解</p>
<p>一道红的发黄的题目，蒟蒻一个”=”调了一中午</p>
<a id="more"></a>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>可以推导出对于每个数n，每个质数出现的次数为:</p>
<p>n/p^1+n/p^2+…+n/p^k</p>
<p>欧拉筛出所有质数，统计即可</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> m=<span class="number">0</span>,p[N],v[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            p[++m]=i,v[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j]&gt;v[i]||p[j]&gt;n/i) <span class="keyword">break</span>;</span><br><span class="line">            v[i*p[j]]=p[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    Prime(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> now=p[i];</span><br><span class="line">        <span class="keyword">while</span>(now&lt;=n)&#123;</span><br><span class="line">            ans+=n/now;</span><br><span class="line">            now*=p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p[i]&lt;&lt;<span class="string">' '</span>&lt;&lt;ans&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>筛法</tag>
      </tags>
  </entry>
  <entry>
    <title>「LG P1120」小木棍</title>
    <url>/2019/10/06/OI/%E9%A2%98%E8%A7%A3/LGP1120%E5%B0%8F%E6%9C%A8%E6%A3%8D/</url>
    <content><![CDATA[<p>给定n个长度不等的小木棍，由一些数量位置长度相等的木棍砍得，问原木棍长度最小可能值，需要手动忽略长度a[i]&gt;50的数据</p>
<a id="more"></a>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><blockquote>
<p><a href="https://www.luogu.org/problem/P1120" target="_blank" rel="noopener">[洛谷 P1120] 小木棍</a></p>
</blockquote>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>一道经典的深搜剪枝习题</p>
<p>以最小长度为目标深搜，搜索满足条件的最小解</p>
<p>剪枝：</p>
<ul>
<li>木棍的最小长度肯定大于小木棍的最大的一个长度，肯定小于所有小木棍长度的总和</li>
<li>原始长度只需要枚举到sum/2，再大就只有一种情况就是sum</li>
<li>可以对小木棍长度从大到小排序方便优化选取的过程(感性理解)</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* P1120 小木棍 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[<span class="number">70</span>], nxt[<span class="number">70</span>], cnt, sum, len;</span><br><span class="line"><span class="keyword">bool</span> used[<span class="number">70</span>], ok;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) f=(ch==<span class="string">'-'</span>)?<span class="number">-1</span>:<span class="number">1</span>,ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x=x*<span class="number">10</span>+(ch-<span class="string">'0'</span>),ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> last, <span class="keyword">int</span> rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (!rest)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == m)</span><br><span class="line">        &#123;</span><br><span class="line">            ok = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">            <span class="keyword">if</span> (!used[i])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        used[i] = <span class="number">1</span>;</span><br><span class="line">        dfs(k + <span class="number">1</span>, i, len - a[i]);</span><br><span class="line">        used[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ok)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = last + <span class="number">1</span>, r = cnt, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt;= rest)</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = l; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!used[i])</span><br><span class="line">        &#123;</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            dfs(k, i, rest - a[i]);</span><br><span class="line">            used[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ok)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (rest == a[i] || rest == len)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            i = nxt[i];</span><br><span class="line">            <span class="keyword">if</span> (i == cnt)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        d = read();</span><br><span class="line">        <span class="keyword">if</span> (d &gt; <span class="number">50</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        a[++cnt] = d;</span><br><span class="line">        sum += d;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + cnt + <span class="number">1</span>, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    nxt[cnt] = cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == a[i + <span class="number">1</span>])</span><br><span class="line">            nxt[i] = nxt[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nxt[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (len = a[<span class="number">1</span>]; len &lt;= sum / <span class="number">2</span>; len++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum % len != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        m = sum / len;</span><br><span class="line">        ok = <span class="number">0</span>;</span><br><span class="line">        used[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">1</span>, len - a[<span class="number">1</span>]);</span><br><span class="line">        used[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ok)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;len;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 580(Div.2)</title>
    <url>/2019/10/04/OI/Codeforces/CF1206Div.2/</url>
    <content><![CDATA[<h1 id="Codeforces-Round-580-Div-2"><a href="#Codeforces-Round-580-Div-2" class="headerlink" title="Codeforces Round #580 Div.2"></a>Codeforces Round #580 Div.2</h1><h2 id="赛程回顾"><a href="#赛程回顾" class="headerlink" title="赛程回顾"></a>赛程回顾</h2><p>蒟蒻来订正不知道多早以前打的比赛了。。。</p>
<p>不知道为什么到现在我无论Div.2或Div.3还是只能切两题，XY巨佬把把AK，蒟蒻只有眼馋的分</p>
<p>蒟蒻10min的时候才切了A，53min的时候在康了XY巨佬的代码下才勉强A掉</p>
<a id="more"></a>
<p>剩下一个C有了一个思路但却是连DFS都不会写，事实如此</p>
<p>于是之后就是颓废时间。。。</p>
<blockquote>
<h2 id="比赛中的失误："><a href="#比赛中的失误：" class="headerlink" title="比赛中的失误："></a>比赛中的失误：</h2><ul>
<li>英文读题能力还是要加强</li>
<li>代码能力低，实现速度慢，浪费时间多</li>
<li>缺乏针对题目的造样例调试能力</li>
<li>没有部分分导致对着一道题猛写一次未交一分未得的情况，OI赛制中也如此，从而失去宝贵的部分分</li>
</ul>
</blockquote>
<h2 id="A-Choose-Two-Numbers-签到题"><a href="#A-Choose-Two-Numbers-签到题" class="headerlink" title="A.Choose Two Numbers [签到题]"></a>A.Choose Two Numbers [签到题]</h2><h3 id="题意简述："><a href="#题意简述：" class="headerlink" title="题意简述："></a>题意简述：</h3><p>给定两个长度为n,m的序列，求出两序列中元素之和不在两序列中的两个元素并输出</p>
<h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><p>取两个序列中的元素的两个最大值，其和定不在任意一个序列中,O(n+m)扫描最值输出即可</p>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> x, y, Max1, Max2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        f = (ch == <span class="string">'-'</span>) ? <span class="number">-1</span> : <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        x = x * <span class="number">10</span> + (ch - <span class="string">'0'</span>), ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        x = read(), Max1 = <span class="built_in">std</span>::max(Max1, x);</span><br><span class="line">    m = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        x = read(), Max2 = <span class="built_in">std</span>::max(Max2, x);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Max1 &lt;&lt; <span class="string">' '</span> &lt;&lt; Max2 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Make-Product-Equal-One-贪心"><a href="#B-Make-Product-Equal-One-贪心" class="headerlink" title="B.Make Product Equal One [贪心]"></a>B.Make Product Equal One [贪心]</h2><h3 id="题意简述：-1"><a href="#题意简述：-1" class="headerlink" title="题意简述："></a>题意简述：</h3><p>给定一个长为n的序列，每次可以花费x的代价将任意一个元素增加或减少x，经过若干次操作，使得Π a[i]=1,(1&lt;=i&lt;=n)</p>
<h3 id="思路浅析"><a href="#思路浅析" class="headerlink" title="思路浅析:"></a>思路浅析:</h3><p>贪心的思想，所有<strong>小于0的数字向-1靠</strong>,ans+-1-a[i]，<strong>大于0的数字向1靠</strong>，有0的话答案就+1，最终如果没有0并且结果为-1，那么说明需要把一个-1改为1，ans+=2，输出即可</p>
<h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans, x, cnt, tot;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        f = (ch == <span class="string">'-'</span>) ? <span class="number">-1</span> : <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        x = x * <span class="number">10</span> + (ch - <span class="string">'0'</span>), ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x = read();</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            ans += -x - <span class="number">1</span>, tot++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">            cnt++, ans++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans += x - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += (!cnt &amp;&amp; tot % <span class="number">2</span>) ? <span class="number">2</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Almost-Equal"><a href="#C-Almost-Equal" class="headerlink" title="C.Almost Equal"></a>C.Almost Equal</h2><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给定一个数字n，将1-n个数字摆成一个环。</p>
<h2 id="待续ing"><a href="#待续ing" class="headerlink" title="待续ing"></a>待续ing</h2>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP初赛复习知识点整理</title>
    <url>/2019/10/04/OI/%E8%AE%AD%E7%BB%83/CSP%E5%88%9D%E8%B5%9B%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="List："><a href="#List：" class="headerlink" title="List："></a>List：</h1><ul>
<li><p>递推</p>
<ul>
<li><p>卡特兰数（节点数为n的二叉树的形态个数）</p>
</li>
<li><p>算法时间复杂度递推方程</p>
</li>
</ul>
</li>
<li><p>多项式时间与NP/P问题</p>
</li>
<li><p>竞赛历史</p>
<ul>
<li><a href="https://oi-wiki.org/intro/oi/" target="_blank" rel="noopener">NOI/IOI/APIO/CSTC相关</a></li>
</ul>
</li>
<li><p>哈夫曼树</p>
</li>
<li><p>逆波兰表达式、前缀表达式、中缀表达式</p>
</li>
<li><p>IP地址</p>
</li>
<li><p>进制</p>
</li>
<li><p>邻接矩阵/邻接表</p>
</li>
<li><p><strong>二叉树</strong></p>
</li>
<li><p>计算机结构基础知识</p>
</li>
<li><p>逻辑运算、非与或</p>
</li>
<li><p>手动递归(大题)</p>
</li>
<li><p>数学期望、概率(建议蒙题)</p>
</li>
<li><p>图论：</p>
<ul>
<li>完全图 [概念]</li>
<li>邻接表 [全部]</li>
<li>DFS序</li>
<li>树边、横叉边、返祖边</li>
<li>各类最短路算法</li>
</ul>
</li>
<li><p>数论基础：</p>
<ul>
<li>同余<ul>
<li>费马小定理</li>
<li>欧拉函数</li>
</ul>
</li>
</ul>
</li>
<li><p>信息存储：(高中技术必修一)</p>
<ul>
<li>空间转换</li>
</ul>
</li>
<li><p>算法时间复杂度递推计算</p>
</li>
<li><p>一些知识：</p>
<ul>
<li>纯函数式语言：haskell</li>
<li><a href="https://baike.baidu.com/item/5G/29780?fr=aladdin" target="_blank" rel="noopener">5G</a></li>
</ul>
</li>
<li><p>基础数据结构</p>
<ul>
<li>栈、单调栈、出入栈顺序</li>
<li>队列、单调队列、循环队列、双端队列(deque)</li>
<li>链表的各种操作(增删查补替排)、双端链表<ul>
<li><strong>交换时</strong>的顺序问题</li>
</ul>
</li>
</ul>
</li>
<li><p>图的各种概念</p>
<ul>
<li>完全图</li>
</ul>
</li>
<li><p>二分图基础</p>
<ul>
<li>最大匹配</li>
<li>最小点覆盖</li>
<li>最小边覆盖</li>
<li>最大独立集</li>
</ul>
</li>
<li><p>机器字长、指令字长、存储字长</p>
</li>
<li><p>计算几何初步</p>
<ul>
<li>自然数幂求和(扰动法)</li>
</ul>
</li>
<li><p>字符串相关</p>
<ul>
<li>KMP算法</li>
<li>Trie树</li>
<li>Hash<ul>
<li>探测冲突</li>
<li>探测因子</li>
</ul>
</li>
</ul>
</li>
<li><p>二份|分治思想</p>
</li>
<li><p>容斥原理</p>
</li>
<li><p>排列组合</p>
</li>
</ul>
<h1 id="计算机发展历史-杂项："><a href="#计算机发展历史-杂项：" class="headerlink" title="计算机发展历史 / 杂项："></a>计算机发展历史 / 杂项：</h1><h2 id="冯诺伊曼计算机模型："><a href="#冯诺伊曼计算机模型：" class="headerlink" title="冯诺伊曼计算机模型："></a>冯诺伊曼计算机模型：</h2><ul>
<li><p>计算机主要由运算器、控制器、存储器、输入输出设备构成</p>
</li>
<li><p><strong>所有的指令都是由操作码和地址码构成</strong></p>
</li>
<li><p>程序和数据都以二进制的形式存放在存储器中</p>
</li>
<li><p>指令在其存储过程中按照执行的顺序存储</p>
</li>
<li><p>以运算器和控制器作为计算机结构的中心</p>
</li>
</ul>
<hr>
<h3 id="各类名词缩写："><a href="#各类名词缩写：" class="headerlink" title="各类名词缩写："></a>各类名词缩写：</h3><ul>
<li><p>计算机/现代集成制造系统 CIMS</p>
</li>
<li><p>计算机辅助制造 CAM</p>
</li>
<li><p>计算机辅助设计 CAD</p>
</li>
<li><p>计算机辅助教学 CAI</p>
</li>
<li><p>算术逻辑单元 ALU</p>
</li>
</ul>
<hr>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul>
<li><p>在关系数据库中，存放在数据库中的数据的逻辑结构以<strong>二维表</strong>为主</p>
</li>
<li><p>办公室自动化(OA)应用分类： 信息处理</p>
</li>
<li><p>衡量CPU速度的单位： MIPS</p>
</li>
<li><p>中国的第一枚计算机芯片： 龙芯</p>
</li>
</ul>
<h1 id="计算机系统："><a href="#计算机系统：" class="headerlink" title="计算机系统："></a>计算机系统：</h1><ul>
<li><p>外存： 硬盘 | SD卡 | 光盘 | 优盘 ……</p>
</li>
<li><p>内存： ROM | RAM | cache</p>
</li>
<li><p>主机：计算机除去输入输出设备以外的主要机体部分，有时候是CPU+内存(主存)，有时候包括主板(详见一本通初赛篇第二版模拟卷八)</p>
</li>
<li><p>硬盘上一个扇区的字节数为 <strong>512</strong></p>
</li>
</ul>
<h1 id="网络："><a href="#网络：" class="headerlink" title="网络："></a>网络：</h1><h2 id="计算机网络发展的三个阶段："><a href="#计算机网络发展的三个阶段：" class="headerlink" title="计算机网络发展的三个阶段："></a>计算机网络发展的三个阶段：</h2><ol>
<li>主机——终端</li>
<li>计算机阶段</li>
<li>Internet阶段(<strong>网络标准化</strong>)<h2 id="计算机网络定义："><a href="#计算机网络定义：" class="headerlink" title="计算机网络定义："></a>计算机网络定义：</h2></li>
</ol>
<ul>
<li><p>计算机网络是指利用通信线路和设备，把分布在不同地理位置上的多台计算机连接起来</p>
</li>
<li><p>计算机之间的通信依靠协议进行。协议是计算机收发数据的规则</p>
</li>
<li><p>计算机网络是一个在协议控制下的多机互联系统</p>
</li>
<li><p>我国1994年正式接入Internet</p>
<h2 id="按地理位置分类"><a href="#按地理位置分类" class="headerlink" title="按地理位置分类"></a>按地理位置分类</h2></li>
<li><p>LAN - 局域网</p>
</li>
<li><p>MAN - 城域网</p>
</li>
<li><p>WAN - 广域网</p>
<h2 id="按拓扑结构分类："><a href="#按拓扑结构分类：" class="headerlink" title="按拓扑结构分类："></a>按拓扑结构分类：</h2></li>
<li><p>星形</p>
</li>
<li><p>总线形</p>
</li>
<li><p>环形</p>
</li>
<li><p>树形</p>
</li>
<li><p>网状形</p>
</li>
</ul>
<p>Internet网连有许多不同拓扑结构的LAN、WAN、MAN，因此没有固定拓扑结构</p>
<h2 id="按采用的交换技术进行分类："><a href="#按采用的交换技术进行分类：" class="headerlink" title="按采用的交换技术进行分类："></a>按采用的交换技术进行分类：</h2><p>电路交换、报文交换、分组交换</p>
<h2 id="体系结构："><a href="#体系结构：" class="headerlink" title="体系结构："></a>体系结构：</h2><p>国际标准化组织提出了<strong>开放式系统互联(OSI)</strong>参考模型，开放性是指任何遵循OSI标准的系统，只要物理上连接起来，他们之间都可以相互通信</p>
<p>但是OSI参考模型并不是网络体系结构，OSI只是描述了每一层的功能，并没有确定每一层的协议，而<strong>网络体系结构是网络层次结构和相关协议的集合</strong></p>
<p>OSI7层模型(自顶向下)：<br>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p>
<p>TCP/IP 4层模型：<br><strong>应用层(对应OSI前三层)</strong>、传输层、国际互联层、<strong>网络接口层(对应OSI后两层)</strong>，中间两层一一对应</p>
<h2 id="IP地址："><a href="#IP地址：" class="headerlink" title="IP地址："></a>IP地址：</h2><blockquote>
<p>用于<strong>表示</strong>Internet<strong>网络</strong>上<strong>节点</strong>的<strong>32位</strong>地址，<strong>V6版本是128位的</strong>，分8组16位</p>
</blockquote>
<ul>
<li><p>每个地址由网络ID和主机ID组成，通常用句点分割的八位字节的十进制数表示：(192.168.7.27)</p>
</li>
<li><p>IP地址分为ABCDE五类，ABC为常用类</p>
</li>
<li><p>网络ID标识大规模的TCP/IP网际网络(由网络组成的网络)内的单个网段</p>
</li>
<li><p>主机ID标识每个网络内部的TCP/IP节点，每个设备的主机ID唯一地识别所在网络的单个系统</p>
</li>
<li><p>IP地址的主机号范围是0-255，但主机ID的所有域不能都为0或255：</p>
<ul>
<li>如果网络ID为10，那么不能分配10.0.0.0和10.255.255.255这两个IP地址</li>
<li>如果网络ID为192.114.31，那么就不能分配192.114.31.0和192.114.31.255</li>
</ul>
</li>
<li><p>ABC类网络地址</p>
<ul>
<li>A类:1.0.0.1 — 126.255.255.254</li>
<li>B类:128.1.0.1 — 191.255.255.254</li>
<li>C类:192.0.0.1 — 223.255.255.254</li>
</ul>
</li>
<li><p>仅供单位内部使用而不用付费的专网IP地址：</p>
<ul>
<li>A:10.0.0.0 – 10.255.255.255</li>
<li>B:172.16.0.0 – 172.31.255.255</li>
<li>C:192.168.0.0 – 192.168.255.255<h2 id="TCP-IP协议："><a href="#TCP-IP协议：" class="headerlink" title="TCP/IP协议："></a>TCP/IP协议：</h2></li>
</ul>
</li>
<li><p>Internet Protocol 、 Transmission Control Protocol</p>
</li>
<li><p>Internet最为基础和重要的协议</p>
</li>
<li><p>用于因特网Internet的一组通信协议，本质上是一种采用分组交换技术的协议，基本思想是把信息分割成一个个不超过一定大小的信息包来传送</p>
</li>
<li><p>TCP-传输控制协议，负责网上信息的正确传输</p>
</li>
<li><p>IP-网际协议，负责将信息从一处传输到另一处</p>
<h3 id="模型："><a href="#模型：" class="headerlink" title="模型："></a>模型：</h3></li>
<li><p>应用层 —- Telent、FTP和e-mail等</p>
</li>
<li><p>传输层 —- TCP和UDP</p>
</li>
<li><p>网络层 —- IP、ICMP和IGMP</p>
</li>
<li><p>网络接口层 —- 设备驱动程序及接口卡</p>
</li>
</ul>
<h2 id="域名和网址"><a href="#域名和网址" class="headerlink" title="域名和网址"></a>域名和网址</h2><p>如果要从一台计算机访问网上另一台计算机，就必须知道对方的网址，这里的网址有IP地址、域名地址和URL两种</p>
<h3 id="IP地址：-1"><a href="#IP地址：-1" class="headerlink" title="IP地址："></a>IP地址：</h3><ul>
<li><p>常见的IP地址分为IPv4和IPv6两大类，在IPv6地址的设计过程中一劳永逸的解决了地址短缺的问题，并且解决了IPv4中的其它一些问题</p>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3></li>
<li><p>为了方便记忆，Internet引入了字符形式的IP地址，即域名。每一层有一个子域名组成，子域名之间用”.”分割，其格式为：开头.主机名.主机类别.国家名(可以不要)</p>
</li>
<li><p>Internet上的域名由域名管理系统(DNS)(域名服务器)统一管理，DNS是一个分布式数据库系统，由域名空间、域名服务器、地址转换请求程序三部分组成，可以方便的转换成数值形式的IP地址进行访问，IP地址也可以反向转换成域名。在Internet上，域名和IP地址都是唯一的</p>
</li>
<li><p>顶级域名：</p>
<ul>
<li>顶级国家域名,cn\us\uk</li>
<li>国际顶级域名,int</li>
<li>通用顶级域名名,com\net\gov\edu…</li>
</ul>
</li>
</ul>
<h2 id="远程登陆："><a href="#远程登陆：" class="headerlink" title="远程登陆："></a>远程登陆：</h2><p>Telent…</p>
<h2 id="文本传输协议-FTP"><a href="#文本传输协议-FTP" class="headerlink" title="文本传输协议(FTP)"></a>文本传输协议(FTP)</h2><p>FTP是因特网上文件传输的基础，通常所说的FTP是基于该协议的一种服务，FTP文本传输协议允许因特网上的用户将一台计算机上的文件传输到另一台上，涵盖几乎所有类型的文件</p>
<h2 id="全球信息网-WWW"><a href="#全球信息网-WWW" class="headerlink" title="全球信息网(WWW)"></a>全球信息网(WWW)</h2><p>又称万维网，采用了“超文本”的技术，其网页文件是用超文本标记语言HTML写的，包含各种多媒体信息及指向其他超文本的链接</p>
<h2 id="统一资源定位器-URL"><a href="#统一资源定位器-URL" class="headerlink" title="统一资源定位器(URL)"></a>统一资源定位器(URL)</h2><p>就是因特网上的资源地址。每个web页面都有一个唯一的地址，格式为：协议名://IP地址或域名</p>
<h2 id="电子邮件及其协议"><a href="#电子邮件及其协议" class="headerlink" title="电子邮件及其协议"></a>电子邮件及其协议</h2><ul>
<li><p>简单邮件传输协议(SMTP)、电子邮件扩展协议(MIME)和POP协议。POP服务需要一个邮件服务器来提供</p>
</li>
<li><p>简单地讲：POP(POP3) - 接收，SMTP - 发送</p>
</li>
</ul>
<hr>
<h2 id="杂项-1"><a href="#杂项-1" class="headerlink" title="杂项"></a>杂项</h2><ul>
<li><p>NNTP\SMTP\POP\FTP\NNTP(网络新闻传输协议)都是Internet的服务</p>
</li>
<li><p>HTTP为超文本传输协议</p>
</li>
<li><p>电邮地址：用户名@服务器主机名</p>
</li>
<li><p>世界上第一个计算机网络：ARPA NET美国国防部高级研究计划网</p>
</li>
<li><p>对于用来说，在访问网络共享资源时候<strong>不需要</strong>考虑资源所在的物理位置</p>
</li>
<li><p>在TCP/IP网络中，数据一旦传送到目的节点，通过<strong>端口号</strong>机制可以将其传送给指定的程序</p>
</li>
<li><p>如果互联的局域网高层分别采用TCP/IP协议与SPX/IPX协议，那么我们可以选择的互联设备是<strong>路由器</strong></p>
</li>
<li><p>CERNET表示中国教育科研计算机网</p>
</li>
<li><p>TCP与UDP的区别：</p>
<ul>
<li>TCP是稳定可靠的，UDP是不稳定不可靠的</li>
<li>TCP是面向字节流的，UDP是基于数据报的</li>
<li>TCP是面向连接的，UDP是面向无连接的</li>
<li>TCP保证数据顺序，UDP不保证</li>
<li>TCP保证数据正确性，UDP可能丢包</li>
<li>UDP程序结构比较简单</li>
</ul>
</li>
<li><p>TCP的三次握手(建立连接)和四次挥手(释放)，了解即可</p>
</li>
<li><p>TCP属于传输层的协议，IP属于网络层的协议</p>
</li>
</ul>
<h1 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h1><h2 id="排序："><a href="#排序：" class="headerlink" title="排序："></a>排序：</h2><ul>
<li>稳定排序：<br>  直接插排、冒泡排序、归并排序、<strong>基数排序</strong></li>
<li>不稳定排序：<br>  希尔排序、选排、堆排、快排<h2 id="算法时间复杂度递推式计算："><a href="#算法时间复杂度递推式计算：" class="headerlink" title="算法时间复杂度递推式计算："></a>算法时间复杂度递推式计算：</h2>套用<a href="https://blog.csdn.net/lanchunhui/article/details/52451362" target="_blank" rel="noopener">主定理法</a>进行分析</li>
</ul>
<p>带log的不能用主定理，直接乘方加一即可，例如若公式中有$log$，那么直接选择$log^2$，以此类推</p>
<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h2><h2 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h2><p>另外比较好的整理</p>
<p>sto<a href="https://www.luogu.org/blog/br2014/chu-sai-zhi-shi-zheng-li" target="_blank" rel="noopener">包容</a></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>计划</tag>
        <tag>初赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra</title>
    <url>/2019/10/03/OI/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Dijkstra/</url>
    <content><![CDATA[<h2 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h2><p>求解图论问题时经常有询问最短路的操作，Dijkstra是一种求解非负权图单源最短路径的有效算法</p>
<h2 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h2><p>以源点为起点，每次从相邻的点中<strong>扩展一个距离最近的新节点</strong>，再以这个点为<strong>中间点</strong>，<strong>更新源点到其他点的最短距离</strong>，由于边权为正，所以不会存在一个距离更短的且没有被扩展过的点，保证算法正确性</p>
<ul>
<li><p>vis数组记录是否更新s点到其他点的最短距离</p>
</li>
<li><p>dis数组记录源点到顶点i的最短距离值</p>
</li>
</ul>
<h2 id="Dijkstra求最短路："><a href="#Dijkstra求最短路：" class="headerlink" title="Dijkstra求最短路："></a>Dijkstra求最短路：</h2><p><strong>算法步骤：</strong></p>
<p>一. 根据题意选定源点s，初始化s到其他点的距离为无穷大，到自身距离为0</p>
<p>二. 重复如下操作直到所有点都被扩展过：</p>
<ol>
<li><p>选择一个未被标记的点k，vis[k] = true,刚开始k = s（源点）</p>
</li>
<li><p>以k为中间点，更新到与k相邻点i的 dis[i] (s到i的距离)</p>
</li>
<li><h2 id="选择一个新的中间点k-保证d-k-是最小的"><a href="#选择一个新的中间点k-保证d-k-是最小的" class="headerlink" title="选择一个新的中间点k,保证d[k]是最小的"></a>选择一个新的中间点k,保证d[k]是最小的</h2><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">for (int i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">/* 初始化源点到其他点的距离 */</span></span><br><span class="line">    dis[i] = inf;</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line">int k = s;</span><br><span class="line">while (!vis[k])</span><br><span class="line">&#123;</span><br><span class="line">    vis[k] = true; <span class="comment">/* 操作1 */</span></span><br><span class="line">    for (int i = head[k]; i; i = edge[i].nxt)</span><br><span class="line">        if (!vis[edge[i].to] &amp;&amp; edge[i].cost + dis[k] &lt; dis[edge[i].to])</span><br><span class="line">            dis[edge[i].to] = dis[k] + edge[i].cost;</span><br><span class="line">    minn = inf;</span><br><span class="line">    for (int i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        if (!vis[i] &amp;&amp; dis[i] &lt; minn)</span><br><span class="line">            minn = dis[i], cu = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>算法时间复杂度为O(n^2)</p>
<h2 id="Dijkstra的堆优化："><a href="#Dijkstra的堆优化：" class="headerlink" title="Dijkstra的堆优化："></a>Dijkstra的堆优化：</h2><p>堆内部结构调整操作为logn复杂度，使用堆优化O(n)的查找新k节点操作可以使整体时间复杂度降到O(nlogn)</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int u, d<span class="comment">;</span></span><br><span class="line">    <span class="keyword">bool </span>operator&lt;(const Node &amp;a) const</span><br><span class="line">    &#123;</span><br><span class="line">        return d &gt; a.d<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line">void <span class="keyword">Dijkstra(int </span>s)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = <span class="number">1</span><span class="comment">; i &lt;= n; i++)</span></span><br><span class="line">        <span class="keyword">dis[i] </span>= inf<span class="comment">;</span></span><br><span class="line">    <span class="keyword">dis[s] </span>= <span class="number">0</span><span class="comment">;</span></span><br><span class="line"><span class="symbol">    std:</span>:priority_queue&lt;Node&gt; Q<span class="comment">;</span></span><br><span class="line">    Q.push((Node)&#123;s, <span class="number">0</span>&#125;)<span class="comment">;</span></span><br><span class="line">    while (!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node fr = Q.top()<span class="comment">;</span></span><br><span class="line">        Q.pop()<span class="comment">;</span></span><br><span class="line">        int u = fr.u, d = fr.d<span class="comment">;</span></span><br><span class="line">        if (d != <span class="keyword">dis[u])</span></span><br><span class="line"><span class="keyword"> </span>           continue<span class="comment">;</span></span><br><span class="line">        for (int i = head[u]<span class="comment">; i; i = e[i].nxt)</span></span><br><span class="line">        &#123;</span><br><span class="line">            int to = e[i].to, val = e[i].val<span class="comment">;</span></span><br><span class="line">            if (<span class="keyword">dis[to] </span>&gt; <span class="keyword">dis[u] </span>+ val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">dis[to] </span>= <span class="keyword">dis[u] </span>+ val<span class="comment">;</span></span><br><span class="line">                Q.push((Node)&#123;to, <span class="keyword">dis[to]&#125;);</span></span><br><span class="line"><span class="keyword"> </span>           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法模板</tag>
        <tag>最短路</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S1大题备战</title>
    <url>/2019/10/02/OI/%E8%AE%AD%E7%BB%83/CSPS1%E5%A4%A7%E9%A2%98/</url>
    <content><![CDATA[<h1 id="前情提要："><a href="#前情提要：" class="headerlink" title="前情提要："></a>前情提要：</h1><p>教练为了防止我们初赛爆零而布置的几道题目</p>
<a id="more"></a>
<h1 id="评价："><a href="#评价：" class="headerlink" title="评价："></a>评价：</h1><p>这种题太水不想做 (XY)</p>
<p>哇这不就是一道傻逼题吗？你搞搞清楚 (TJ)</p>
<p>tql,赶紧% (Me)</p>
<h1 id="艰难的完成-ing-："><a href="#艰难的完成-ing-：" class="headerlink" title="艰难的完成(ing)："></a>艰难的完成(ing)：</h1><blockquote>
<h2 id="P1076-寻宝-你"><a href="#P1076-寻宝-你" class="headerlink" title="P1076 寻宝 [%你]"></a><a href="https://www.luogu.org/problem/P1076" target="_blank" rel="noopener">P1076 寻宝</a> [%你]</h2></blockquote>
<p>蒟蒻读题30min，做题1.5min，大佬们只要两分钟，题意不赘述了，大佬们肯定秒懂</p>
<p>一道纯模拟</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define int long long</span></span><br><span class="line">using namespace std<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">int n, m, a[<span class="number">10001</span>][<span class="number">101</span>], <span class="keyword">b[10001][101], </span>c[<span class="number">10001</span>], sum, k, ans, q<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">int read()</span><br><span class="line">&#123;</span><br><span class="line">    int x = <span class="number">0</span>, f = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    char ch = getchar()<span class="comment">;</span></span><br><span class="line">    while (!isdigit(ch))</span><br><span class="line">        f = (ch == <span class="string">'-'</span>) ? -<span class="number">1</span> : <span class="number">1</span>, ch = getchar()<span class="comment">;</span></span><br><span class="line">    while (isdigit(ch))</span><br><span class="line">        x = x * <span class="number">10</span> + (ch - <span class="string">'0'</span>), ch = getchar()<span class="comment">;</span></span><br><span class="line">    return x * f<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    n = read(), m = read()<span class="comment">;</span></span><br><span class="line">    for (int i = <span class="number">1</span><span class="comment">; i &lt;= n; i++)</span></span><br><span class="line">        for (int <span class="keyword">j </span>= <span class="number">0</span><span class="comment">; j &lt;= m - 1; j++)</span></span><br><span class="line">            a[i][<span class="keyword">j] </span>= read(), <span class="keyword">b[i][j] </span>= read(), c[i] += a[i][<span class="keyword">j];</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>   k = read()<span class="comment">;</span></span><br><span class="line">    for (int <span class="keyword">j </span>= <span class="number">1</span><span class="comment">; j &lt;= n; j++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum += <span class="keyword">b[j][k];</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>       ans = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">        q = k<span class="comment">;</span></span><br><span class="line">        <span class="keyword">b[j][q] </span>= (<span class="keyword">b[j][q] </span>- <span class="number">1</span>) % c[<span class="keyword">j] </span>+ <span class="number">1</span><span class="comment">;</span></span><br><span class="line">        while (ans &lt; <span class="keyword">b[j][q])</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>       &#123;</span><br><span class="line">            ans += a[<span class="keyword">j][k];</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>           if (ans == <span class="keyword">b[j][q])</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>               <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>           k++<span class="comment">;</span></span><br><span class="line">            if (k == m)</span><br><span class="line">                k = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum % <span class="number">20123</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h2 id="P1077-摆花-DP"><a href="#P1077-摆花-DP" class="headerlink" title="P1077 摆花 [DP]"></a><a href="https://www.luogu.org/problem/P1077" target="_blank" rel="noopener">P1077 摆花</a> [DP]</h2></blockquote>
<h3 id="题意简述："><a href="#题意简述：" class="headerlink" title="题意简述："></a>题意简述：</h3><p>给定n,m,a[1]…a[n]表示有n种花每种的数量不超过a[i]盆，一共可以摆m盆，求摆花的方案数，答案%19260817，呸%1e6+7;</p>
<h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><p>设f[i][j]表示前i种花摆了j盆的情况种数</p>
<p>f[i][j]=sigma_f[i-1][j-k],0&lt;=k&lt;=min(a[i],j)</p>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[maxn], f[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(j, a[i]); k++)</span><br><span class="line">                f[i][j] = (f[i][j] + f[i - <span class="number">1</span>][j - k]) % Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n][m] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h2 id="P1965-转圈游戏-数学-分治"><a href="#P1965-转圈游戏-数学-分治" class="headerlink" title="P1965 转圈游戏 [数学] [分治]"></a><a href="https://www.luogu.org/problem/P1965" target="_blank" rel="noopener">P1965 转圈游戏</a> [数学] [分治]</h2></blockquote>
<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给定n,m,k,x，求(x+m*10^k)%n</p>
<h3 id="思路浅析："><a href="#思路浅析：" class="headerlink" title="思路浅析："></a>思路浅析：</h3><p>根据分配律，得到原式=x%n+(m%n)*(10^k%n)，用快速幂计算出10^k%n即可</p>
<h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k, x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        f = (ch == <span class="string">'-'</span>) ? <span class="number">-1</span> : <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        x = x * <span class="number">10</span> + (ch - <span class="string">'0'</span>), ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>, t = a;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = res * t % n;</span><br><span class="line">        t = t * t % n;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=read(),m=read(),k=read(),x=read();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(x%n+m%n*QuickPow(<span class="number">10</span>,k)%n)%n&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h2 id="P1970-花匠-贪心"><a href="#P1970-花匠-贪心" class="headerlink" title="P1970 花匠 [贪心]"></a><a href="https://www.luogu.org/problem/P1970" target="_blank" rel="noopener">P1970 花匠</a> [贪心]</h2></blockquote>
<h3 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给定长为n的序列，求出最长的波动序列的长度，也就是以增减增减的形式存在的序列</p>
<h3 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h3><pre><code>input:
5
5 3 2 1 2
output:
3
(5,1,2)</code></pre><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>此题蒟蒻读完题后一口贪心结论糊中，%你要求去最大长度输出即可</p>
<h3 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">bool</span> f;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">2</span>] &gt;= a[<span class="number">1</span>])</span><br><span class="line">        f = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">false</span> &amp;&amp; i == n)</span><br><span class="line">            ans++;</span><br><span class="line">        <span class="keyword">if</span> (f)</span><br><span class="line">            <span class="keyword">if</span> (a[i + <span class="number">1</span>] &lt; a[i])</span><br><span class="line">                ans++, f = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">if</span> (a[i + <span class="number">1</span>] &gt; a[i])</span><br><span class="line">                ans++, f = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h2 id="P2058-海港-模拟"><a href="#P2058-海港-模拟" class="headerlink" title="P2058 海港 [模拟]"></a><a href="https://www.luogu.org/problem/P2058" target="_blank" rel="noopener">P2058 海港</a> [模拟]</h2></blockquote>
<h3 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h3><p>略..</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>纯模拟题，但是空间会爆，使用new int即可</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> sor[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ship</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">int</span> *people;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, n, l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        r = i; <span class="comment">//右区间</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[i].t, &amp;a[i].p);</span><br><span class="line">        a[i].people = <span class="keyword">new</span> <span class="keyword">int</span>[a[i].p]; <span class="comment">//动态数组，保证空间不被开爆；</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].p; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].people[j]);</span><br><span class="line">            sor[a[i].people[j]]++;</span><br><span class="line">            <span class="keyword">if</span> (sor[a[i].people[j]] == <span class="number">1</span>)</span><br><span class="line">                ans++; <span class="comment">//进入队列，如果还没有该国的人，+1；</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[r].t - a[l].t &gt;= <span class="number">86400</span>)</span><br><span class="line">            <span class="keyword">while</span> (a[r].t - a[l].t &gt;= <span class="number">86400</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[l].p; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    sor[a[l].people[j]]--;</span><br><span class="line">                    <span class="keyword">if</span> (sor[a[l].people[j]] == <span class="number">0</span>)</span><br><span class="line">                        ans--; <span class="comment">//退出队列</span></span><br><span class="line">                &#125;</span><br><span class="line">                l++; <span class="comment">//左区间</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h2 id="P2239-螺旋矩阵-规律-数学"><a href="#P2239-螺旋矩阵-规律-数学" class="headerlink" title="P2239 螺旋矩阵 [规律] [数学]"></a><a href="https://www.luogu.org/problem/P2239" target="_blank" rel="noopener">P2239 螺旋矩阵</a> [规律] [数学]</h2></blockquote>
<h3 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h3><pre><code>            1 2 3
给定一个形如 8 9 4的蛇形数阵，要求输出第(i,j)位置上的数字
            7 6 5</code></pre><h3 id="思路浅析：-1"><a href="#思路浅析：-1" class="headerlink" title="思路浅析："></a>思路浅析：</h3><p>P2661 信息传递</p>
<p>P2678 跳石头</p>
<p>P3951 小凯的疑惑</p>
<p>P3956 棋盘</p>
<p>P3958 奶酪</p>
<p>P1078 文化之旅</p>
<p>P1082 同余方程</p>
<p>P1351 联合权值</p>
<p>P1982 小朋友的数字</p>
<p>P2296 寻找道路</p>
<p>P2671 求和</p>
<p>P2672 推销员</p>
<p>P2822 组合数问题</p>
<p>P5018 对称二叉树</p>
<p>P5020 货币系统</p>
<p>P1080 国王游戏</p>
<p>P1083 借教室</p>
<p>P1850 换教室</p>
<p>P1941 飞扬的小鸟</p>
<p>P1955 [NOI2015]程序自动分析</p>
<p>P1966 火柴排队</p>
<p>P1967 货车运输</p>
<p>P1983 车站分级</p>
<p>P2044 [NOI2012]随机数生成器</p>
<p>P2119 魔法阵</p>
<p>P2168 [NOI2015]荷马史诗</p>
<p>P2258 子矩阵</p>
<p>P2312 解方程</p>
<p>P2668 斗地主</p>
<p>P2679 子串</p>
<p>P2827 蚯蚓</p>
<p>P2831 愤怒的小鸟</p>
<p>P3952 时间复杂度</p>
<p>P3957 跳房子</p>
<p>P5017 摆渡车</p>
<p>P5022 旅行</p>
<p>P2280 [HNOI2003]激光炸弹</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>计划</tag>
        <tag>初赛</tag>
      </tags>
  </entry>
</search>
